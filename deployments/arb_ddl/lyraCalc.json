{
  "address": "0xC20bCD4336fe0bfA2DeE36Ab2bEA18BC1aF65Dc5",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_optionMarket",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_optionMarketPricer",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_baseExchangeAdapter",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_optionGreekCache",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_liquidityPool",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "baseExchangeAdapter",
      "outputs": [
        {
          "internalType": "contract IBaseExchangeAdapter",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "premium",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "expiry",
          "type": "uint256"
        }
      ],
      "name": "calculateOptionPriceFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "fee",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum IOptionMarket.OptionType",
          "name": "optionType",
          "type": "uint8"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "callPrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "putPrice",
              "type": "uint256"
            },
            {
              "internalType": "int256",
              "name": "callDelta",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "putDelta",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "vega",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "stdVega",
              "type": "uint256"
            }
          ],
          "internalType": "struct BlackScholes.PricesDeltaStdVega",
          "name": "pricesDeltaStdVega",
          "type": "tuple"
        }
      ],
      "name": "calculatePremium",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "premium",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "spotPrice",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "id",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "boardId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "strikePrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "skew",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "int256",
                  "name": "callDelta",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "putDelta",
                  "type": "int256"
                },
                {
                  "internalType": "uint256",
                  "name": "stdVega",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "callPrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "putPrice",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IOptionGreekCache.StrikeGreeks",
              "name": "greeks",
              "type": "tuple"
            },
            {
              "internalType": "int256",
              "name": "callExposure",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "putExposure",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "skewVariance",
              "type": "uint256"
            }
          ],
          "internalType": "struct IOptionGreekCache.StrikeCache",
          "name": "strikeCache",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "id",
              "type": "uint256"
            },
            {
              "internalType": "uint256[]",
              "name": "strikes",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256",
              "name": "expiry",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "iv",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "int256",
                  "name": "netDelta",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "netStdVega",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "netOptionValue",
                  "type": "int256"
                }
              ],
              "internalType": "struct IOptionGreekCache.NetGreeks",
              "name": "netGreeks",
              "type": "tuple"
            },
            {
              "internalType": "uint256",
              "name": "updatedAt",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "updatedAtPrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxSkewVariance",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "ivVariance",
              "type": "uint256"
            }
          ],
          "internalType": "struct IOptionGreekCache.OptionBoardCache",
          "name": "boardCache",
          "type": "tuple"
        }
      ],
      "name": "calculatePricesDeltaStdVega",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "callPrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "putPrice",
              "type": "uint256"
            },
            {
              "internalType": "int256",
              "name": "callDelta",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "putDelta",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "vega",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "stdVega",
              "type": "uint256"
            }
          ],
          "internalType": "struct BlackScholes.PricesDeltaStdVega",
          "name": "pricesDeltaStdVega",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "spotPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "expiry",
          "type": "uint256"
        }
      ],
      "name": "calculateSpotPriceFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "fee",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "strikeId",
          "type": "uint256"
        },
        {
          "internalType": "enum IOptionMarket.TradeDirection",
          "name": "tradeDirection",
          "type": "uint8"
        },
        {
          "internalType": "enum IOptionMarket.OptionType",
          "name": "optionType",
          "type": "uint8"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "isBuy",
          "type": "bool"
        },
        {
          "internalType": "bool",
          "name": "isForceClose",
          "type": "bool"
        }
      ],
      "name": "calculateTotalCost",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "totalCost",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum IOptionMarket.TradeDirection",
          "name": "tradeDirection",
          "type": "uint8"
        },
        {
          "internalType": "enum IOptionMarket.OptionType",
          "name": "optionType",
          "type": "uint8"
        },
        {
          "internalType": "bool",
          "name": "isForceClose",
          "type": "bool"
        }
      ],
      "name": "getSpotPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "spotPrice",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "liquidityPool",
      "outputs": [
        {
          "internalType": "contract ILiquidityPool",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "optionGreekCache",
      "outputs": [
        {
          "internalType": "contract IOptionGreekCache",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "optionMarket",
      "outputs": [
        {
          "internalType": "contract IOptionMarket",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "optionMarketPricer",
      "outputs": [
        {
          "internalType": "contract IOptionMarketPricer",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "id",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "strikePrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "skew",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "longCall",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "shortCallBase",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "shortCallQuote",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "longPut",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "shortPut",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "boardId",
              "type": "uint256"
            }
          ],
          "internalType": "struct IOptionMarket.Strike",
          "name": "strike",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "id",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "boardId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "strikePrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "skew",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "int256",
                  "name": "callDelta",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "putDelta",
                  "type": "int256"
                },
                {
                  "internalType": "uint256",
                  "name": "stdVega",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "callPrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "putPrice",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IOptionGreekCache.StrikeGreeks",
              "name": "greeks",
              "type": "tuple"
            },
            {
              "internalType": "int256",
              "name": "callExposure",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "putExposure",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "skewVariance",
              "type": "uint256"
            }
          ],
          "internalType": "struct IOptionGreekCache.StrikeCache",
          "name": "strikeCache",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "id",
              "type": "uint256"
            },
            {
              "internalType": "uint256[]",
              "name": "strikes",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256",
              "name": "expiry",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "iv",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "int256",
                  "name": "netDelta",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "netStdVega",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "netOptionValue",
                  "type": "int256"
                }
              ],
              "internalType": "struct IOptionGreekCache.NetGreeks",
              "name": "netGreeks",
              "type": "tuple"
            },
            {
              "internalType": "uint256",
              "name": "updatedAt",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "updatedAtPrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxSkewVariance",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "ivVariance",
              "type": "uint256"
            }
          ],
          "internalType": "struct IOptionGreekCache.OptionBoardCache",
          "name": "boardCache",
          "type": "tuple"
        },
        {
          "internalType": "uint256",
          "name": "vega",
          "type": "uint256"
        }
      ],
      "name": "preparetionPricing",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "optionPrice",
              "type": "uint256"
            },
            {
              "internalType": "int256",
              "name": "preTradeAmmNetStdVega",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "postTradeAmmNetStdVega",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "callDelta",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "volTraded",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "ivVariance",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "vega",
              "type": "uint256"
            }
          ],
          "internalType": "struct IOptionGreekCache.TradePricing",
          "name": "pricing",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "isBuy",
          "type": "bool"
        },
        {
          "internalType": "enum IOptionMarket.TradeDirection",
          "name": "tradeDirection",
          "type": "uint8"
        },
        {
          "internalType": "enum IOptionMarket.OptionType",
          "name": "optionType",
          "type": "uint8"
        },
        {
          "internalType": "bool",
          "name": "isForceClose",
          "type": "bool"
        }
      ],
      "name": "preparetionTrade",
      "outputs": [
        {
          "components": [
            {
              "internalType": "bool",
              "name": "isBuy",
              "type": "bool"
            },
            {
              "internalType": "bool",
              "name": "isForceClose",
              "type": "bool"
            },
            {
              "internalType": "enum IOptionMarket.TradeDirection",
              "name": "tradeDirection",
              "type": "uint8"
            },
            {
              "internalType": "enum IOptionMarket.OptionType",
              "name": "optionType",
              "type": "uint8"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "expiry",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "strikePrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "spotPrice",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "freeLiquidity",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "burnableLiquidity",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "reservedCollatLiquidity",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "pendingDeltaLiquidity",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "usedDeltaLiquidity",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "NAV",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "longScaleFactor",
                  "type": "uint256"
                }
              ],
              "internalType": "struct ILiquidityPool.Liquidity",
              "name": "liquidity",
              "type": "tuple"
            }
          ],
          "internalType": "struct IOptionMarket.TradeParameters",
          "name": "trade",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x76a104a08130fe538179f2c510637afa655e90f98f12fee1df9c7847aa3a050d",
  "receipt": {
    "to": null,
    "from": "0x8B57f3a9bDf2cfdBF9B2627ff8bEa86fB5641a50",
    "contractAddress": "0xC20bCD4336fe0bfA2DeE36Ab2bEA18BC1aF65Dc5",
    "transactionIndex": 2,
    "gasUsed": "12610541",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xe766160902f6bde00595db843f68f8f94e55c211f2b9c19b15f2a3d52914ecb2",
    "transactionHash": "0x76a104a08130fe538179f2c510637afa655e90f98f12fee1df9c7847aa3a050d",
    "logs": [],
    "blockNumber": 124420704,
    "cumulativeGasUsed": "14297079",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x919E5e0C096002cb8a21397D724C4e3EbE77bC15",
    "0xdacEE745b517C9cDfd7F749dFF9eB03f51a27A13",
    "0x7D135662818d3540bd6f23294bFDB6946c52C9AB",
    "0x4b236Ac3B8d4666CbdC4E725C4366382AA30d86b",
    "0xB619913921356904Bf62abA7271E694FD95AA10D"
  ],
  "numDeployments": 1,
  "solcInputHash": "d6aa06f46094ef6cc349ec184dafdae2",
  "metadata": "{\"compiler\":{\"version\":\"0.8.16+commit.07a7930e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_optionMarket\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_optionMarketPricer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_baseExchangeAdapter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_optionGreekCache\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_liquidityPool\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"baseExchangeAdapter\",\"outputs\":[{\"internalType\":\"contract IBaseExchangeAdapter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"premium\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"name\":\"calculateOptionPriceFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IOptionMarket.OptionType\",\"name\":\"optionType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"callPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"putPrice\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"callDelta\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"putDelta\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"vega\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stdVega\",\"type\":\"uint256\"}],\"internalType\":\"struct BlackScholes.PricesDeltaStdVega\",\"name\":\"pricesDeltaStdVega\",\"type\":\"tuple\"}],\"name\":\"calculatePremium\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"premium\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"spotPrice\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boardId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"skew\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"callDelta\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"putDelta\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"stdVega\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"callPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"putPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct IOptionGreekCache.StrikeGreeks\",\"name\":\"greeks\",\"type\":\"tuple\"},{\"internalType\":\"int256\",\"name\":\"callExposure\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"putExposure\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"skewVariance\",\"type\":\"uint256\"}],\"internalType\":\"struct IOptionGreekCache.StrikeCache\",\"name\":\"strikeCache\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"strikes\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"iv\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"netDelta\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"netStdVega\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"netOptionValue\",\"type\":\"int256\"}],\"internalType\":\"struct IOptionGreekCache.NetGreeks\",\"name\":\"netGreeks\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAtPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSkewVariance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ivVariance\",\"type\":\"uint256\"}],\"internalType\":\"struct IOptionGreekCache.OptionBoardCache\",\"name\":\"boardCache\",\"type\":\"tuple\"}],\"name\":\"calculatePricesDeltaStdVega\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"callPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"putPrice\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"callDelta\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"putDelta\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"vega\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stdVega\",\"type\":\"uint256\"}],\"internalType\":\"struct BlackScholes.PricesDeltaStdVega\",\"name\":\"pricesDeltaStdVega\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"spotPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"name\":\"calculateSpotPriceFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"strikeId\",\"type\":\"uint256\"},{\"internalType\":\"enum IOptionMarket.TradeDirection\",\"name\":\"tradeDirection\",\"type\":\"uint8\"},{\"internalType\":\"enum IOptionMarket.OptionType\",\"name\":\"optionType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isForceClose\",\"type\":\"bool\"}],\"name\":\"calculateTotalCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalCost\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IOptionMarket.TradeDirection\",\"name\":\"tradeDirection\",\"type\":\"uint8\"},{\"internalType\":\"enum IOptionMarket.OptionType\",\"name\":\"optionType\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isForceClose\",\"type\":\"bool\"}],\"name\":\"getSpotPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"spotPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityPool\",\"outputs\":[{\"internalType\":\"contract ILiquidityPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optionGreekCache\",\"outputs\":[{\"internalType\":\"contract IOptionGreekCache\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optionMarket\",\"outputs\":[{\"internalType\":\"contract IOptionMarket\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optionMarketPricer\",\"outputs\":[{\"internalType\":\"contract IOptionMarketPricer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"skew\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"longCall\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortCallBase\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortCallQuote\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"longPut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortPut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boardId\",\"type\":\"uint256\"}],\"internalType\":\"struct IOptionMarket.Strike\",\"name\":\"strike\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boardId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"skew\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"callDelta\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"putDelta\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"stdVega\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"callPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"putPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct IOptionGreekCache.StrikeGreeks\",\"name\":\"greeks\",\"type\":\"tuple\"},{\"internalType\":\"int256\",\"name\":\"callExposure\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"putExposure\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"skewVariance\",\"type\":\"uint256\"}],\"internalType\":\"struct IOptionGreekCache.StrikeCache\",\"name\":\"strikeCache\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"strikes\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"iv\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"netDelta\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"netStdVega\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"netOptionValue\",\"type\":\"int256\"}],\"internalType\":\"struct IOptionGreekCache.NetGreeks\",\"name\":\"netGreeks\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAtPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSkewVariance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ivVariance\",\"type\":\"uint256\"}],\"internalType\":\"struct IOptionGreekCache.OptionBoardCache\",\"name\":\"boardCache\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"vega\",\"type\":\"uint256\"}],\"name\":\"preparetionPricing\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"optionPrice\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"preTradeAmmNetStdVega\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"postTradeAmmNetStdVega\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"callDelta\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"volTraded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ivVariance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vega\",\"type\":\"uint256\"}],\"internalType\":\"struct IOptionGreekCache.TradePricing\",\"name\":\"pricing\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"enum IOptionMarket.TradeDirection\",\"name\":\"tradeDirection\",\"type\":\"uint8\"},{\"internalType\":\"enum IOptionMarket.OptionType\",\"name\":\"optionType\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isForceClose\",\"type\":\"bool\"}],\"name\":\"preparetionTrade\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isForceClose\",\"type\":\"bool\"},{\"internalType\":\"enum IOptionMarket.TradeDirection\",\"name\":\"tradeDirection\",\"type\":\"uint8\"},{\"internalType\":\"enum IOptionMarket.OptionType\",\"name\":\"optionType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spotPrice\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"freeLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnableLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reservedCollatLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingDeltaLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usedDeltaLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"NAV\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"longScaleFactor\",\"type\":\"uint256\"}],\"internalType\":\"struct ILiquidityPool.Liquidity\",\"name\":\"liquidity\",\"type\":\"tuple\"}],\"internalType\":\"struct IOptionMarket.TradeParameters\",\"name\":\"trade\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"0nika0\",\"kind\":\"dev\",\"methods\":{\"calculateOptionPriceFee(uint256,uint256)\":{\"params\":{\"expiry\":\"The expiration time of the option.\",\"premium\":\"The premium amount of the option.\"},\"returns\":{\"fee\":\"The calculated fee based on the provided premium and expiration time.\"}},\"calculatePremium(uint8,uint256,(uint256,uint256,int256,int256,uint256,uint256))\":{\"params\":{\"amount\":\"The amount of options being traded.\",\"optionType\":\"The type of the option: LONG_CALL, LONG_PUT, SHORT_CALL_BASE, SHORT_CALL_QUOTE, SHORT_PUT_QUOTE.\",\"pricesDeltaStdVega\":\"The struct containing calculated prices, delta, and standard vega.\"},\"returns\":{\"premium\":\"The calculated premium for the option trade.\"}},\"calculatePricesDeltaStdVega(uint256,(uint256,uint256,uint256,uint256,(int256,int256,uint256,uint256,uint256),int256,int256,uint256),(uint256,uint256[],uint256,uint256,(int256,int256,int256),uint256,uint256,uint256,uint256))\":{\"details\":\"This function calculates various option-related values using the Black-Scholes formula.\",\"params\":{\"boardCache\":\"The cached data for the option board.\",\"spotPrice\":\"The current spot price of the underlying asset.\",\"strikeCache\":\"The cached data for the strike associated with the option.\"},\"returns\":{\"pricesDeltaStdVega\":\"A struct containing calculated prices, delta, and standard vega.\"}},\"calculateSpotPriceFee(uint256,uint256,uint256)\":{\"params\":{\"amount\":\"The amount of options being traded.\",\"expiry\":\"The expiration time of the options.\",\"spotPrice\":\"The current spot price of the underlying asset.\"},\"returns\":{\"fee\":\"The calculated fee based on the provided spot price and trade parameters.\"}},\"calculateTotalCost(uint256,uint8,uint8,uint256,bool,bool)\":{\"details\":\"This function calculates the approximate value of an option trade based on various parameters.\",\"params\":{\"amount\":\"The amount of options being traded.\",\"isBuy\":\"True if it's a buy trade, false if it's a sell trade.\",\"isForceClose\":\"True if the trade is a force close.\",\"optionType\":\"The type of the option: LONG_CALL, LONG_PUT, SHORT_CALL_BASE, SHORT_CALL_QUOTE, SHORT_PUT_QUOTE.\",\"strikeId\":\"The ID of the strike for the option trade.\",\"tradeDirection\":\"The direction of the trade: OPEN, CLOSE, LIQUIDATE.\"},\"returns\":{\"totalCost\":\"The total cost of the trade including fees.\"}},\"getSpotPrice(uint8,uint8,bool)\":{\"params\":{\"isForceClose\":\"True if the trade is a force close.\",\"optionType\":\"The type of the option: LONG_CALL, LONG_PUT, SHORT_CALL_BASE, SHORT_CALL_QUOTE, SHORT_PUT_QUOTE.\",\"tradeDirection\":\"The direction of the trade: OPEN, CLOSE, LIQUIDATE.\"},\"returns\":{\"spotPrice\":\"The calculated spot price for the trade.\"}},\"preparetionPricing((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),(uint256,uint256,uint256,uint256,(int256,int256,uint256,uint256,uint256),int256,int256,uint256),(uint256,uint256[],uint256,uint256,(int256,int256,int256),uint256,uint256,uint256,uint256),uint256)\":{\"params\":{\"boardCache\":\"The cached data for the option board.\",\"strike\":\"The information about the strike.\",\"strikeCache\":\"The cached data for the strike.\",\"vega\":\"The calculated vega value.\"},\"returns\":{\"pricing\":\"The populated trade pricing data.\"}},\"preparetionTrade(uint256,bool,uint8,uint8,bool)\":{\"params\":{\"amount\":\"The amount of options being traded.\",\"isBuy\":\"True if it's a buy trade, false if it's a sell trade.\",\"isForceClose\":\"True if the trade is a force close.\",\"optionType\":\"The type of the option: LONG_CALL, LONG_PUT, SHORT_CALL_BASE, SHORT_CALL_QUOTE, SHORT_PUT_QUOTE.\",\"tradeDirection\":\"The direction of the trade: OPEN, CLOSE, LIQUIDATE.\"},\"returns\":{\"trade\":\"The populated trade parameters.\"}}},\"title\":\"LyraCalc\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"calculateOptionPriceFee(uint256,uint256)\":{\"notice\":\"Calculates the fee based on the option premium and expiration time, considering time weighting.\"},\"calculatePremium(uint8,uint256,(uint256,uint256,int256,int256,uint256,uint256))\":{\"notice\":\"Calculates the premium for the option trade based on the option type and other parameters.\"},\"calculatePricesDeltaStdVega(uint256,(uint256,uint256,uint256,uint256,(int256,int256,uint256,uint256,uint256),int256,int256,uint256),(uint256,uint256[],uint256,uint256,(int256,int256,int256),uint256,uint256,uint256,uint256))\":{\"notice\":\"Calculates option prices, delta, and standard vega using the Black-Scholes model.\"},\"calculateSpotPriceFee(uint256,uint256,uint256)\":{\"notice\":\"Calculates the fee based on spot price and trade amount, taking into account time weighting.\"},\"calculateTotalCost(uint256,uint8,uint8,uint256,bool,bool)\":{\"notice\":\"Calculates the total cost for a given trade.\"},\"getSpotPrice(uint8,uint8,bool)\":{\"notice\":\"Retrieves the appropriate spot price based on trade direction, option type, and force close status.\"},\"preparetionPricing((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),(uint256,uint256,uint256,uint256,(int256,int256,uint256,uint256,uint256),int256,int256,uint256),(uint256,uint256[],uint256,uint256,(int256,int256,int256),uint256,uint256,uint256,uint256),uint256)\":{\"notice\":\"Prepares trade pricing data based on strike and greek cache information.\"},\"preparetionTrade(uint256,bool,uint8,uint8,bool)\":{\"notice\":\"Prepares deal parameters for totalCost calculation.\"}},\"notice\":\"A smart contract for calculating the total cost of option trades and related fees. This contract leverages the Black-Scholes model and various pricing parameters to estimate trade costs.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/LyraCalc.sol\":\"LyraCalc\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\\n\",\"keccak256\":\"0xa56ca923f70c1748830700250b19c61b70db9a683516dc5e216694a50445d99c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0x52a8cfb0f5239d11b457dcdd1b326992ef672714ca8da71a157255bddd13f3ad\",\"license\":\"MIT\"},\"contracts/LyraCalc.sol\":{\"content\":\"/**\\n * SPDX-License-Identifier: GPL-3.0-or-later\\n * DeDeLend\\n * Copyright (C) 2023 DeDeLend\\n *\\n * This program is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU General Public License as published by\\n * the Free Software Foundation, either version 3 of the License, or\\n * (at your option) any later version.\\n *\\n * This program is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n * GNU General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License\\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n **/\\npragma solidity 0.8.16;\\n\\nimport {BlackScholes} from\\\"./libraries/BlackScholes.sol\\\";\\nimport {DecimalMath} from \\\"./synthetix/DecimalMath.sol\\\";\\nimport {SignedDecimalMath} from \\\"./synthetix/SignedDecimalMath.sol\\\";\\nimport {SafeCast} from \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport {IOptionMarket} from \\\"./interfaces/IOptionMarket.sol\\\";\\nimport {IBaseExchangeAdapter} from \\\"./interfaces/IBaseExchangeAdapter.sol\\\";\\nimport {IOptionGreekCache} from \\\"./interfaces/IOptionGreekCache.sol\\\";\\nimport {IOptionMarketPricer} from \\\"./interfaces/IOptionMarketPricer.sol\\\";\\nimport {ILiquidityPool} from \\\"./interfaces/ILiquidityPool.sol\\\";\\n\\n/**\\n * @title LyraCalc\\n * @author 0nika0\\n * @notice A smart contract for calculating the total cost of option trades and related fees.\\n * This contract leverages the Black-Scholes model and various pricing parameters to estimate trade costs.\\n */\\ncontract LyraCalc {\\n    using DecimalMath for uint;\\n    using SignedDecimalMath for int;\\n    using BlackScholes for BlackScholes.BlackScholesInputs;\\n    \\n    // Contracts and libraries\\n    IOptionMarket public optionMarket;\\n    IOptionMarketPricer public optionMarketPricer;\\n    IBaseExchangeAdapter public baseExchangeAdapter;\\n    IOptionGreekCache public optionGreekCache;\\n    ILiquidityPool public liquidityPool;\\n\\n    constructor(\\n        address _optionMarket,\\n        address _optionMarketPricer,\\n        address _baseExchangeAdapter,\\n        address _optionGreekCache,\\n        address _liquidityPool\\n    ) {\\n        optionMarket = IOptionMarket(_optionMarket);\\n        optionMarketPricer = IOptionMarketPricer(_optionMarketPricer);\\n        baseExchangeAdapter = IBaseExchangeAdapter(_baseExchangeAdapter);\\n        optionGreekCache = IOptionGreekCache(_optionGreekCache);\\n        liquidityPool = ILiquidityPool(_liquidityPool);\\n    }\\n\\n    // VIEW FUNCTIONS //\\n\\n    /**\\n     * @notice Calculates the total cost for a given trade.\\n     * @dev This function calculates the approximate value of an option trade based on various parameters.\\n     * @param strikeId The ID of the strike for the option trade.\\n     * @param tradeDirection The direction of the trade: OPEN, CLOSE, LIQUIDATE.\\n     * @param optionType The type of the option: LONG_CALL, LONG_PUT, SHORT_CALL_BASE, SHORT_CALL_QUOTE, SHORT_PUT_QUOTE.\\n     * @param amount The amount of options being traded.\\n     * @param isBuy True if it's a buy trade, false if it's a sell trade.\\n     * @param isForceClose True if the trade is a force close.\\n     * @return totalCost The total cost of the trade including fees.\\n     */\\n    function calculateTotalCost(\\n        uint256 strikeId,\\n        IOptionMarket.TradeDirection tradeDirection, \\n        IOptionMarket.OptionType optionType, \\n        uint256 amount,\\n        bool isBuy,\\n        bool isForceClose\\n    ) public view returns (uint256 totalCost) {\\n        // Prepare the trade parameters based on input values\\n        IOptionMarket.TradeParameters memory trade = preparetionTrade(\\n            amount,\\n            isBuy,\\n            tradeDirection,\\n            optionType,\\n            isForceClose\\n        );\\n\\n        // Get strike and board information\\n        (IOptionMarket.Strike memory strike, IOptionMarket.OptionBoard memory board) = optionMarket.getStrikeAndBoard(strikeId);\\n        IOptionGreekCache.StrikeCache memory strikeCache = optionGreekCache.getStrikeCache(strikeId);\\n        IOptionGreekCache.OptionBoardCache memory boardCache = optionGreekCache.getOptionBoardCache(strikeCache.boardId);\\n\\n        // Calculate prices, delta, and standard vega using Black-Scholes model\\n        BlackScholes.PricesDeltaStdVega memory pricesDeltaStdVega = calculatePricesDeltaStdVega(\\n            trade.spotPrice,\\n            strikeCache,\\n            boardCache\\n        );\\n\\n        // Prepare trade pricing data\\n        IOptionGreekCache.TradePricing memory pricing = preparetionPricing(\\n            strike,\\n            strikeCache,\\n            boardCache,\\n            pricesDeltaStdVega.vega\\n        );\\n\\n        // Calculate the impact of implied volatility on the trade's price\\n        (, uint256 newSkew) = optionMarketPricer.ivImpactForTrade(trade, boardCache.iv, strike.skew);\\n\\n        // Calculate the premium for the option trade\\n        uint256 premium = calculatePremium(\\n            optionType,\\n            amount,\\n            pricesDeltaStdVega\\n        );\\n\\n        // Calculate fees related to option price and spot price\\n        uint256 optionPriceFee = calculateOptionPriceFee(premium, board.expiry);\\n        uint256 spotPriceFee = calculateSpotPriceFee(trade.spotPrice, trade.amount, board.expiry);\\n\\n        // Calculate vega utility and variance fees\\n        IOptionMarketPricer.VegaUtilFeeComponents memory vegaUtilFeeComponents = optionMarketPricer.getVegaUtilFee(\\n            trade,\\n            pricing\\n        );\\n        IOptionMarketPricer.VarianceFeeComponents memory varianceFeeComponents = optionMarketPricer.getVarianceFee(\\n            trade,\\n            pricing,\\n            newSkew\\n        );\\n\\n        // Calculate the total fee for the trade\\n        uint totalFee = optionPriceFee +\\n            spotPriceFee +\\n            vegaUtilFeeComponents.vegaUtilFee +\\n            varianceFeeComponents.varianceFee;\\n\\n        // Calculate the total cost based on trade direction and fees\\n        if (trade.isBuy) {\\n            totalCost = premium + totalFee;\\n        } else {\\n            if (totalFee > premium) {\\n                totalFee = premium;\\n                totalCost = 0;\\n            } else {\\n                totalCost = premium - totalFee;\\n            }\\n        }\\n        // Return the calculated total cost\\n    }\\n\\n    /**\\n     * @notice Calculates option prices, delta, and standard vega using the Black-Scholes model.\\n     * @dev This function calculates various option-related values using the Black-Scholes formula.\\n     * @param spotPrice The current spot price of the underlying asset.\\n     * @param strikeCache The cached data for the strike associated with the option.\\n     * @param boardCache The cached data for the option board.\\n     * @return pricesDeltaStdVega A struct containing calculated prices, delta, and standard vega.\\n     */\\n    function calculatePricesDeltaStdVega(\\n        uint256 spotPrice,\\n        IOptionGreekCache.StrikeCache memory strikeCache,\\n        IOptionGreekCache.OptionBoardCache memory boardCache\\n    ) public view returns (BlackScholes.PricesDeltaStdVega memory pricesDeltaStdVega) {\\n        // Construct inputs for the Black-Scholes formula\\n        pricesDeltaStdVega = BlackScholes\\n            .BlackScholesInputs({\\n                timeToExpirySec: _timeToMaturitySeconds(boardCache.expiry), // Calculate time to maturity in seconds\\n                volatilityDecimal: boardCache.iv.multiplyDecimal(strikeCache.skew), // Adjusted volatility based on strike skew\\n                spotDecimal: spotPrice, // Current spot price\\n                strikePriceDecimal: strikeCache.strikePrice, // Strike price of the option\\n                rateDecimal: baseExchangeAdapter.rateAndCarry(address(optionMarket)) // Risk-free rate\\n            })\\n            .pricesDeltaStdVega();\\n    }\\n\\n    /**\\n     * @notice Retrieves the appropriate spot price based on trade direction, option type, and force close status.\\n     * @param tradeDirection The direction of the trade: OPEN, CLOSE, LIQUIDATE.\\n     * @param optionType The type of the option: LONG_CALL, LONG_PUT, SHORT_CALL_BASE, SHORT_CALL_QUOTE, SHORT_PUT_QUOTE.\\n     * @param isForceClose True if the trade is a force close.\\n     * @return spotPrice The calculated spot price for the trade.\\n     */\\n    function getSpotPrice(\\n        IOptionMarket.TradeDirection tradeDirection,\\n        IOptionMarket.OptionType optionType,\\n        bool isForceClose\\n    ) public view returns (uint256 spotPrice) {\\n        IBaseExchangeAdapter.PriceType pricingType;\\n\\n        // Determine the appropriate pricing type based on trade direction and option type\\n        if (tradeDirection == IOptionMarket.TradeDirection.LIQUIDATE) {\\n            pricingType = IBaseExchangeAdapter.PriceType.REFERENCE;\\n        } else if (optionType == IOptionMarket.OptionType.LONG_CALL || optionType == IOptionMarket.OptionType.SHORT_PUT_QUOTE) {\\n            pricingType = tradeDirection == IOptionMarket.TradeDirection.OPEN\\n                ? IBaseExchangeAdapter.PriceType.MAX_PRICE\\n                : (isForceClose ? IBaseExchangeAdapter.PriceType.FORCE_MIN : IBaseExchangeAdapter.PriceType.MIN_PRICE);\\n        } else {\\n            pricingType = tradeDirection == IOptionMarket.TradeDirection.OPEN\\n                ? IBaseExchangeAdapter.PriceType.MIN_PRICE\\n                : (isForceClose ? IBaseExchangeAdapter.PriceType.FORCE_MAX : IBaseExchangeAdapter.PriceType.MAX_PRICE);\\n        }\\n\\n        // Retrieve the spot price based on the selected pricing type\\n        spotPrice = baseExchangeAdapter.getSpotPriceForMarket(address(optionMarket), pricingType);\\n    }\\n\\n    /**\\n     * @notice Calculates the fee based on spot price and trade amount, taking into account time weighting.\\n     * @param spotPrice The current spot price of the underlying asset.\\n     * @param amount The amount of options being traded.\\n     * @param expiry The expiration time of the options.\\n     * @return fee The calculated fee based on the provided spot price and trade parameters.\\n     */\\n    function calculateSpotPriceFee(\\n        uint256 spotPrice,\\n        uint256 amount,\\n        uint256 expiry\\n    ) public view returns (uint256 fee) {\\n        // Get the pricing parameters from the option market pricer\\n        IOptionMarketPricer.PricingParameters memory pricingParams = optionMarketPricer.pricingParams();\\n\\n        // Calculate the time-weighted spot price fee using the provided parameters\\n        uint timeWeightedSpotPriceFee = optionMarketPricer.getTimeWeightedFee(\\n            expiry,\\n            pricingParams.spotPriceFee1xPoint,\\n            pricingParams.spotPriceFee2xPoint,\\n            pricingParams.spotPriceFeeCoefficient\\n        );\\n\\n        // Calculate the final fee by multiplying the time-weighted fee by the spot price and trade amount\\n        fee = timeWeightedSpotPriceFee.multiplyDecimal(spotPrice).multiplyDecimal(amount);\\n    }\\n\\n    /**\\n     * @notice Calculates the fee based on the option premium and expiration time, considering time weighting.\\n     * @param premium The premium amount of the option.\\n     * @param expiry The expiration time of the option.\\n     * @return fee The calculated fee based on the provided premium and expiration time.\\n     */\\n    function calculateOptionPriceFee(\\n        uint256 premium,\\n        uint256 expiry\\n    ) public view returns (uint256 fee) {\\n        // Get the pricing parameters from the option market pricer\\n        IOptionMarketPricer.PricingParameters memory pricingParams = optionMarketPricer.pricingParams();\\n\\n        // Calculate the time-weighted option price fee using the provided parameters\\n        uint timeWeightedOptionPriceFee = optionMarketPricer.getTimeWeightedFee(\\n            expiry,\\n            pricingParams.optionPriceFee1xPoint,\\n            pricingParams.optionPriceFee2xPoint,\\n            pricingParams.optionPriceFeeCoefficient\\n        );\\n\\n        // Calculate the final fee by multiplying the time-weighted fee by the option premium\\n        fee = timeWeightedOptionPriceFee.multiplyDecimal(premium);\\n    } \\n\\n    /**\\n     * @notice Prepares deal parameters for totalCost calculation.\\n     * @param amount The amount of options being traded.\\n     * @param isBuy True if it's a buy trade, false if it's a sell trade.\\n     * @param tradeDirection The direction of the trade: OPEN, CLOSE, LIQUIDATE.\\n     * @param optionType The type of the option: LONG_CALL, LONG_PUT, SHORT_CALL_BASE, SHORT_CALL_QUOTE, SHORT_PUT_QUOTE.\\n     * @param isForceClose True if the trade is a force close.\\n     * @return trade The populated trade parameters.\\n    */\\n    function preparetionTrade(\\n        uint256 amount,\\n        bool isBuy,\\n        IOptionMarket.TradeDirection tradeDirection,\\n        IOptionMarket.OptionType optionType,\\n        bool isForceClose\\n    ) public view returns (IOptionMarket.TradeParameters memory trade) {\\n        // Get the current Net Asset Value (NAV) from the liquidity pool\\n        trade.liquidity.NAV = liquidityPool.getLiquidity().NAV;\\n\\n        // Populate the trade parameters based on provided inputs\\n        trade.amount = amount;\\n        trade.isForceClose = isForceClose;\\n        trade.isBuy = isBuy;\\n\\n        // Get the spot price for the trade based on trade direction, option type, and force close status\\n        trade.spotPrice = getSpotPrice(\\n            tradeDirection,\\n            optionType,\\n            isForceClose\\n        );\\n\\n        // Set the option type and trade direction\\n        trade.optionType = optionType;\\n        trade.tradeDirection = tradeDirection;\\n    }\\n\\n    /**\\n     * @notice Prepares trade pricing data based on strike and greek cache information.\\n     * @param strike The information about the strike.\\n     * @param strikeCache The cached data for the strike.\\n     * @param boardCache The cached data for the option board.\\n     * @param vega The calculated vega value.\\n     * @return pricing The populated trade pricing data.\\n     */\\n    function preparetionPricing(\\n        IOptionMarket.Strike memory strike,\\n        IOptionGreekCache.StrikeCache memory strikeCache,\\n        IOptionGreekCache.OptionBoardCache memory boardCache,\\n        uint256 vega\\n    ) public view returns (IOptionGreekCache.TradePricing memory pricing) {\\n        // Get the global cache from the option Greek cache\\n        IOptionGreekCache.GlobalCache memory globalCache = optionGreekCache.getGlobalCache();\\n\\n        // Calculate new exposures and net standard vega difference\\n        int256 newCallExposure = SafeCast.toInt256(strike.longCall) - SafeCast.toInt256(strike.shortCallBase + strike.shortCallQuote);\\n        int256 newPutExposure = SafeCast.toInt256(strike.longPut) - SafeCast.toInt256(strike.shortPut);\\n        int256 netStdVegaDiff = (newCallExposure + newPutExposure - strikeCache.callExposure - strikeCache.putExposure)\\n            .multiplyDecimal(SafeCast.toInt256(strikeCache.greeks.stdVega));\\n\\n\\n        // Populate pricing data based on provided inputs\\n        pricing.preTradeAmmNetStdVega = -globalCache.netGreeks.netStdVega;\\n        pricing.postTradeAmmNetStdVega = -globalCache.netGreeks.netStdVega + netStdVegaDiff;\\n        pricing.volTraded = boardCache.iv.multiplyDecimal(strikeCache.skew);\\n        pricing.vega = vega;\\n        pricing.ivVariance = boardCache.ivVariance;\\n    }\\n\\n    // INTERNAL FUNCTIONS //\\n\\n    /**\\n     * @notice Calculates the time remaining to maturity in seconds for a given expiry timestamp.\\n     * @param expiry The expiration timestamp of the option.\\n     * @return timeToMaturitySeconds The remaining time to maturity in seconds.\\n     */\\n    function _timeToMaturitySeconds(uint256 expiry) internal view returns (uint256 timeToMaturitySeconds) {\\n        // Calculate the time remaining to maturity using the _getSecondsTo function\\n        timeToMaturitySeconds = _getSecondsTo(block.timestamp, expiry);\\n    }\\n\\n    // PURE FUNCTIONS //\\n\\n    /**\\n     * @notice Calculates the premium for the option trade based on the option type and other parameters.\\n     * @param optionType The type of the option: LONG_CALL, LONG_PUT, SHORT_CALL_BASE, SHORT_CALL_QUOTE, SHORT_PUT_QUOTE.\\n     * @param amount The amount of options being traded.\\n     * @param pricesDeltaStdVega The struct containing calculated prices, delta, and standard vega.\\n     * @return premium The calculated premium for the option trade.\\n     */\\n    function calculatePremium(\\n        IOptionMarket.OptionType optionType,\\n        uint256 amount,\\n        BlackScholes.PricesDeltaStdVega memory pricesDeltaStdVega\\n    ) public pure returns (uint256 premium) {\\n        // Determine the appropriate option price based on the option type\\n        uint256 optionPrice = (optionType != IOptionMarket.OptionType.LONG_PUT && optionType != IOptionMarket.OptionType.SHORT_PUT_QUOTE)\\n            ? pricesDeltaStdVega.callPrice\\n            : pricesDeltaStdVega.putPrice;\\n        // Calculate the premium by multiplying the option price by the trade amount\\n        premium = optionPrice.multiplyDecimal(amount);\\n    }\\n\\n    /**\\n     * @notice Calculates the time difference in seconds between two timestamps.\\n     * @param fromTime The starting timestamp.\\n     * @param toTime The ending timestamp.\\n     * @return secondsTo The time difference in seconds between the two timestamps.\\n     */\\n    function _getSecondsTo(uint256 fromTime, uint256 toTime) internal pure returns (uint256) {\\n        // Calculate the time difference in seconds between the two timestamps\\n        if (toTime > fromTime) {\\n            return toTime - fromTime;\\n        }\\n            return 0;\\n    }\\n\\n}\\n\",\"keccak256\":\"0xe08dc6730047e8d99fca47b0e52d9a4d923f2d248a483edd7c6767872b37490d\",\"license\":\"GPL-3.0-or-later\"},\"contracts/interfaces/IBaseExchangeAdapter.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.16;\\n\\ninterface IBaseExchangeAdapter {\\n    enum PriceType {\\n      MIN_PRICE, // minimise the spot based on logic in adapter - can revert\\n      MAX_PRICE, // maximise the spot based on logic in adapter\\n      REFERENCE,\\n      FORCE_MIN, // minimise the spot based on logic in adapter - shouldn't revert unless feeds are compromised\\n      FORCE_MAX\\n    }\\n\\n    function getSpotPriceForMarket(address optionMarket, PriceType pricing) external view returns (uint256 spotPrice); \\n    function rateAndCarry(address /*_optionMarket*/) external view returns (int);\\n}\",\"keccak256\":\"0xdee46f2aba351a427c07da39272857d34fa6e24b826cd3063dbe9e4ad0fda3e9\",\"license\":\"UNLICENSED\"},\"contracts/interfaces/ILiquidityPool.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.16;\\n\\ninterface ILiquidityPool {\\n    struct Liquidity {\\n        // Amount of liquidity available for option collateral and premiums\\n        uint freeLiquidity;\\n        // Amount of liquidity available for withdrawals - different to freeLiquidity\\n        uint burnableLiquidity;\\n        // Amount of liquidity reserved for long options sold to traders\\n        uint reservedCollatLiquidity;\\n        // Portion of liquidity reserved for delta hedging (quote outstanding)\\n        uint pendingDeltaLiquidity;\\n        // Current value of delta hedge\\n        uint usedDeltaLiquidity;\\n        // Net asset value, including everything and netOptionValue\\n        uint NAV;\\n        // longs scaled down by this factor in a contract adjustment event\\n        uint longScaleFactor;\\n    }\\n\\n    function getLiquidity() external view returns (Liquidity memory);\\n}\\n\",\"keccak256\":\"0xbd3d662581eec56ca61fc92dedb2fa44991320f5d61aa1e01ce5068d648cd063\",\"license\":\"UNLICENSED\"},\"contracts/interfaces/IOptionGreekCache.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.16;\\n\\ninterface IOptionGreekCache {\\n    struct StrikeGreeks {\\n        int callDelta;\\n        int putDelta;\\n        uint stdVega;\\n        uint callPrice;\\n        uint putPrice;\\n    }\\n\\n    struct NetGreeks {\\n        int netDelta;\\n        int netStdVega;\\n        int netOptionValue;\\n    }\\n\\n    struct TradePricing {\\n        uint optionPrice;\\n        int preTradeAmmNetStdVega;\\n        int postTradeAmmNetStdVega;\\n        int callDelta;\\n        uint volTraded;\\n        uint ivVariance;\\n        uint vega;\\n    }\\n\\n    struct StrikeCache {\\n        uint id;\\n        uint boardId;\\n        uint strikePrice;\\n        uint skew;\\n        StrikeGreeks greeks;\\n        int callExposure; // long - short\\n        int putExposure; // long - short\\n        uint skewVariance; // (GWAVSkew - skew)\\n    }\\n\\n    struct OptionBoardCache {\\n        uint id;\\n        uint[] strikes;\\n        uint expiry;\\n        uint iv;\\n        NetGreeks netGreeks;\\n        uint updatedAt;\\n        uint updatedAtPrice;\\n        uint maxSkewVariance;\\n        uint ivVariance;\\n    }\\n\\n    struct GlobalCache {\\n        uint minUpdatedAt;\\n        uint minUpdatedAtPrice;\\n        uint maxUpdatedAtPrice;\\n        uint maxSkewVariance;\\n        uint maxIvVariance;\\n        NetGreeks netGreeks;\\n    }\\n\\n    function getStrikeCache(uint strikeId) external view returns (StrikeCache memory); \\n    function getOptionBoardCache(uint boardId) external view returns (OptionBoardCache memory); \\n    function getGlobalCache() external view returns (GlobalCache memory);\\n}\",\"keccak256\":\"0xf28ec4cc5e1d2b0206fc29ad9c481e4daa3502774285e991b65f95bb6fc999cf\",\"license\":\"UNLICENSED\"},\"contracts/interfaces/IOptionMarket.sol\":{\"content\":\"pragma solidity 0.8.16;\\n\\nimport \\\"./ILiquidityPool.sol\\\";\\n\\nimport {ERC20} from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\ninterface IOptionMarket {\\n    enum TradeDirection {\\n        OPEN,\\n        CLOSE,\\n        LIQUIDATE\\n    }\\n\\n    enum OptionType {\\n        LONG_CALL,\\n        LONG_PUT,\\n        SHORT_CALL_BASE,\\n        SHORT_CALL_QUOTE,\\n        SHORT_PUT_QUOTE\\n    }\\n\\n    struct TradeInputParameters {\\n        // id of strike\\n        uint strikeId;\\n        // OptionToken ERC721 id for position (set to 0 for new positions)\\n        uint positionId;\\n        // number of sub-orders to break order into (reduces slippage)\\n        uint iterations;\\n        // type of option to trade\\n        OptionType optionType;\\n        // number of contracts to trade\\n        uint amount;\\n        // final amount of collateral to leave in OptionToken position\\n        uint setCollateralTo;\\n        // revert trade if totalCost is below this value\\n        uint minTotalCost;\\n        // revert trade if totalCost is above this value\\n        uint maxTotalCost;\\n        // referrer emitted in Trade event, no on-chain interaction\\n        address referrer;\\n    }\\n\\n    struct Strike {\\n        // strike listing identifier\\n        uint256 id;\\n        // strike price\\n        uint256 strikePrice;\\n        // volatility component specific to the strike listing (boardIv * skew = vol of strike)\\n        uint256 skew;\\n        // total user long call exposure\\n        uint256 longCall;\\n        // total user short call (base collateral) exposure\\n        uint256 shortCallBase;\\n        // total user short call (quote collateral) exposure\\n        uint256 shortCallQuote;\\n        // total user long put exposure\\n        uint256 longPut;\\n        // total user short put (quote collateral) exposure\\n        uint256 shortPut;\\n        // id of board to which strike belongs\\n        uint256 boardId;\\n    }\\n\\n    struct OptionBoard {\\n        // board identifier\\n        uint256 id;\\n        // expiry of all strikes belonging to board\\n        uint256 expiry;\\n        // volatility component specific to board (boardIv * skew = vol of strike)\\n        uint256 iv;\\n        // admin settable flag blocking all trading on this board\\n        bool frozen;\\n        // list of all strikes belonging to this board\\n        uint256[] strikeIds;\\n    }\\n\\n    struct TradeParameters {\\n        bool isBuy;\\n        bool isForceClose;\\n        TradeDirection tradeDirection;\\n        OptionType optionType;\\n        uint amount;\\n        uint expiry;\\n        uint strikePrice;\\n        uint spotPrice;\\n        ILiquidityPool.Liquidity liquidity;\\n    }\\n\\n    struct Result {\\n        uint positionId;\\n        uint totalCost;\\n        uint totalFee;\\n    }\\n\\n    function getStrike(uint strikeId) external view returns (Strike memory);\\n    function getStrikeAndBoard(uint strikeId) external view returns (Strike memory, OptionBoard memory);\\n    function openPosition(TradeInputParameters memory params) external returns (Result memory result);\\n    function closePosition(TradeInputParameters memory params) external returns (Result memory result);\\n    function quoteAsset() external view returns(ERC20);\\n    function baseAsset() external view returns(ERC20);\\n}\",\"keccak256\":\"0xf6a785a97351fc8981dbb416b094135ea7ee17b6e27ebeffe824117b8b0d0519\"},\"contracts/interfaces/IOptionMarketPricer.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.16;\\n\\nimport \\\"./IOptionMarket.sol\\\";\\nimport \\\"./IOptionGreekCache.sol\\\";\\n\\ninterface IOptionMarketPricer {\\n    struct VegaUtilFeeComponents {\\n        int preTradeAmmNetStdVega;\\n        int postTradeAmmNetStdVega;\\n        uint vegaUtil;\\n        uint volTraded;\\n        uint NAV;\\n        uint vegaUtilFee;\\n    }\\n\\n    struct PricingParameters {\\n        // Percentage of option price that is charged as a fee\\n        uint optionPriceFeeCoefficient;\\n        // Refer to: getTimeWeightedFee()\\n        uint optionPriceFee1xPoint;\\n        uint optionPriceFee2xPoint;\\n        // Percentage of spot price that is charged as a fee per option\\n        uint spotPriceFeeCoefficient;\\n        // Refer to: getTimeWeightedFee()\\n        uint spotPriceFee1xPoint;\\n        uint spotPriceFee2xPoint;\\n        // Refer to: getVegaUtilFee()\\n        uint vegaFeeCoefficient;\\n        // The amount of options traded to move baseIv for the board up or down 1 point (depending on trade direction)\\n        uint standardSize;\\n        // The relative move of skew for a given strike based on standard sizes traded\\n        uint skewAdjustmentFactor;\\n    }\\n\\n    struct VarianceFeeComponents {\\n        uint varianceFeeCoefficient;\\n        uint vega;\\n        uint vegaCoefficient;\\n        uint skew;\\n        uint skewCoefficient;\\n        uint ivVariance;\\n        uint ivVarianceCoefficient;\\n        uint varianceFee;\\n    }\\n\\n    function getVegaUtilFee(\\n        IOptionMarket.TradeParameters memory trade,\\n        IOptionGreekCache.TradePricing memory pricing\\n    ) external view returns (VegaUtilFeeComponents memory vegaUtilFeeComponents);\\n\\n    function getTimeWeightedFee(\\n        uint expiry,\\n        uint pointA,\\n        uint pointB,\\n        uint coefficient\\n    ) external view returns (uint timeWeightedFee);\\n\\n    function getVarianceFee(\\n      IOptionMarket.TradeParameters memory trade,\\n      IOptionGreekCache.TradePricing memory pricing,\\n      uint skew\\n    ) external view returns (VarianceFeeComponents memory varianceFeeComponents);\\n\\n    function pricingParams() external view returns (PricingParameters memory);\\n\\n    function ivImpactForTrade(\\n        IOptionMarket.TradeParameters memory trade,\\n        uint boardBaseIv,\\n        uint strikeSkew\\n    ) external view returns (uint newBaseIv, uint newSkew);\\n}\",\"keccak256\":\"0x5c894f5e4c1b0744e88d7fbc7d41f9b32289ed10dc39b06fcb75181b63a44089\",\"license\":\"UNLICENSED\"},\"contracts/libraries/BlackScholes.sol\":{\"content\":\"//SPDX-License-Identifier: ISC\\npragma solidity 0.8.16;\\n\\n// Libraries\\nimport \\\"../synthetix/SignedDecimalMath.sol\\\";\\nimport \\\"../synthetix/DecimalMath.sol\\\";\\nimport \\\"./FixedPointMathLib.sol\\\";\\nimport \\\"./Math.sol\\\";\\n\\n/**\\n * @title BlackScholes\\n * @author Lyra\\n * @dev Contract to compute the black scholes price of options. Where the unit is unspecified, it should be treated as a\\n * PRECISE_DECIMAL, which has 1e27 units of precision. The default decimal matches the ethereum standard of 1e18 units\\n * of precision.\\n */\\nlibrary BlackScholes {\\n  using DecimalMath for uint;\\n  using SignedDecimalMath for int;\\n\\n  struct PricesDeltaStdVega {\\n    uint callPrice;\\n    uint putPrice;\\n    int callDelta;\\n    int putDelta;\\n    uint vega;\\n    uint stdVega;\\n  }\\n\\n  /**\\n   * @param timeToExpirySec Number of seconds to the expiry of the option\\n   * @param volatilityDecimal Implied volatility over the period til expiry as a percentage\\n   * @param spotDecimal The current price of the base asset\\n   * @param strikePriceDecimal The strikePrice price of the option\\n   * @param rateDecimal The percentage risk free rate + carry cost\\n   */\\n  struct BlackScholesInputs {\\n    uint timeToExpirySec;\\n    uint volatilityDecimal;\\n    uint spotDecimal;\\n    uint strikePriceDecimal;\\n    int rateDecimal;\\n  }\\n\\n  uint private constant SECONDS_PER_YEAR = 31536000;\\n  /// @dev Internally this library uses 27 decimals of precision\\n  uint private constant PRECISE_UNIT = 1e27;\\n  uint private constant SQRT_TWOPI = 2506628274631000502415765285;\\n  /// @dev Value to use to avoid any division by 0 or values near 0\\n  uint private constant MIN_T_ANNUALISED = PRECISE_UNIT / SECONDS_PER_YEAR; // 1 second\\n  uint private constant MIN_VOLATILITY = PRECISE_UNIT / 10000; // 0.001%\\n  uint private constant VEGA_STANDARDISATION_MIN_DAYS = 7 days;\\n  /// @dev Magic numbers for normal CDF\\n  uint private constant SPLIT = 7071067811865470000000000000;\\n  uint private constant N0 = 220206867912376000000000000000;\\n  uint private constant N1 = 221213596169931000000000000000;\\n  uint private constant N2 = 112079291497871000000000000000;\\n  uint private constant N3 = 33912866078383000000000000000;\\n  uint private constant N4 = 6373962203531650000000000000;\\n  uint private constant N5 = 700383064443688000000000000;\\n  uint private constant N6 = 35262496599891100000000000;\\n  uint private constant M0 = 440413735824752000000000000000;\\n  uint private constant M1 = 793826512519948000000000000000;\\n  uint private constant M2 = 637333633378831000000000000000;\\n  uint private constant M3 = 296564248779674000000000000000;\\n  uint private constant M4 = 86780732202946100000000000000;\\n  uint private constant M5 = 16064177579207000000000000000;\\n  uint private constant M6 = 1755667163182640000000000000;\\n  uint private constant M7 = 88388347648318400000000000;\\n\\n  /////////////////////////////////////\\n  // Option Pricing public functions //\\n  /////////////////////////////////////\\n\\n  /**\\n   * @dev Returns call and put prices for options with given parameters.\\n   */\\n  function optionPrices(BlackScholesInputs memory bsInput) public pure returns (uint call, uint put) {\\n    uint tAnnualised = _annualise(bsInput.timeToExpirySec);\\n    uint spotPrecise = bsInput.spotDecimal.decimalToPreciseDecimal();\\n    uint strikePricePrecise = bsInput.strikePriceDecimal.decimalToPreciseDecimal();\\n    int ratePrecise = bsInput.rateDecimal.decimalToPreciseDecimal();\\n    (int d1, int d2) = _d1d2(\\n      tAnnualised,\\n      bsInput.volatilityDecimal.decimalToPreciseDecimal(),\\n      spotPrecise,\\n      strikePricePrecise,\\n      ratePrecise\\n    );\\n    (call, put) = _optionPrices(tAnnualised, spotPrecise, strikePricePrecise, ratePrecise, d1, d2);\\n    return (call.preciseDecimalToDecimal(), put.preciseDecimalToDecimal());\\n  }\\n\\n  /**\\n   * @dev Returns call/put prices and delta/stdVega for options with given parameters.\\n   */\\n  function pricesDeltaStdVega(BlackScholesInputs memory bsInput) public pure returns (PricesDeltaStdVega memory) {\\n    uint tAnnualised = _annualise(bsInput.timeToExpirySec);\\n    uint spotPrecise = bsInput.spotDecimal.decimalToPreciseDecimal();\\n\\n    (int d1, int d2) = _d1d2(\\n      tAnnualised,\\n      bsInput.volatilityDecimal.decimalToPreciseDecimal(),\\n      spotPrecise,\\n      bsInput.strikePriceDecimal.decimalToPreciseDecimal(),\\n      bsInput.rateDecimal.decimalToPreciseDecimal()\\n    );\\n    (uint callPrice, uint putPrice) = _optionPrices(\\n      tAnnualised,\\n      spotPrecise,\\n      bsInput.strikePriceDecimal.decimalToPreciseDecimal(),\\n      bsInput.rateDecimal.decimalToPreciseDecimal(),\\n      d1,\\n      d2\\n    );\\n    (uint vegaPrecise, uint stdVegaPrecise) = _standardVega(d1, spotPrecise, bsInput.timeToExpirySec);\\n    (int callDelta, int putDelta) = _delta(d1);\\n\\n    return\\n      PricesDeltaStdVega(\\n        callPrice.preciseDecimalToDecimal(),\\n        putPrice.preciseDecimalToDecimal(),\\n        callDelta.preciseDecimalToDecimal(),\\n        putDelta.preciseDecimalToDecimal(),\\n        vegaPrecise.preciseDecimalToDecimal(),\\n        stdVegaPrecise.preciseDecimalToDecimal()\\n      );\\n  }\\n\\n  /**\\n   * @dev Returns call delta given parameters.\\n   */\\n\\n  function delta(BlackScholesInputs memory bsInput) public pure returns (int callDeltaDecimal, int putDeltaDecimal) {\\n    uint tAnnualised = _annualise(bsInput.timeToExpirySec);\\n    uint spotPrecise = bsInput.spotDecimal.decimalToPreciseDecimal();\\n\\n    (int d1, ) = _d1d2(\\n      tAnnualised,\\n      bsInput.volatilityDecimal.decimalToPreciseDecimal(),\\n      spotPrecise,\\n      bsInput.strikePriceDecimal.decimalToPreciseDecimal(),\\n      bsInput.rateDecimal.decimalToPreciseDecimal()\\n    );\\n\\n    (int callDelta, int putDelta) = _delta(d1);\\n    return (callDelta.preciseDecimalToDecimal(), putDelta.preciseDecimalToDecimal());\\n  }\\n\\n  /**\\n   * @dev Returns non-normalized vega given parameters. Quoted in cents.\\n   */\\n  function vega(BlackScholesInputs memory bsInput) public pure returns (uint vegaDecimal) {\\n    uint tAnnualised = _annualise(bsInput.timeToExpirySec);\\n    uint spotPrecise = bsInput.spotDecimal.decimalToPreciseDecimal();\\n\\n    (int d1, ) = _d1d2(\\n      tAnnualised,\\n      bsInput.volatilityDecimal.decimalToPreciseDecimal(),\\n      spotPrecise,\\n      bsInput.strikePriceDecimal.decimalToPreciseDecimal(),\\n      bsInput.rateDecimal.decimalToPreciseDecimal()\\n    );\\n    return _vega(tAnnualised, spotPrecise, d1).preciseDecimalToDecimal();\\n  }\\n\\n  //////////////////////\\n  // Computing Greeks //\\n  //////////////////////\\n\\n  /**\\n   * @dev Returns internal coefficients of the Black-Scholes call price formula, d1 and d2.\\n   * @param tAnnualised Number of years to expiry\\n   * @param volatility Implied volatility over the period til expiry as a percentage\\n   * @param spot The current price of the base asset\\n   * @param strikePrice The strikePrice price of the option\\n   * @param rate The percentage risk free rate + carry cost\\n   */\\n  function _d1d2(\\n    uint tAnnualised,\\n    uint volatility,\\n    uint spot,\\n    uint strikePrice,\\n    int rate\\n  ) internal pure returns (int d1, int d2) {\\n    // Set minimum values for tAnnualised and volatility to not break computation in extreme scenarios\\n    // These values will result in option prices reflecting only the difference in stock/strikePrice, which is expected.\\n    // This should be caught before calling this function, however the function shouldn't break if the values are 0.\\n    tAnnualised = tAnnualised < MIN_T_ANNUALISED ? MIN_T_ANNUALISED : tAnnualised;\\n    volatility = volatility < MIN_VOLATILITY ? MIN_VOLATILITY : volatility;\\n\\n    int vtSqrt = int(volatility.multiplyDecimalRoundPrecise(_sqrtPrecise(tAnnualised)));\\n    int log = FixedPointMathLib.lnPrecise(int(spot.divideDecimalRoundPrecise(strikePrice)));\\n    int v2t = (int(volatility.multiplyDecimalRoundPrecise(volatility) / 2) + rate).multiplyDecimalRoundPrecise(\\n      int(tAnnualised)\\n    );\\n    d1 = (log + v2t).divideDecimalRoundPrecise(vtSqrt);\\n    d2 = d1 - vtSqrt;\\n  }\\n\\n  /**\\n   * @dev Internal coefficients of the Black-Scholes call price formula.\\n   * @param tAnnualised Number of years to expiry\\n   * @param spot The current price of the base asset\\n   * @param strikePrice The strikePrice price of the option\\n   * @param rate The percentage risk free rate + carry cost\\n   * @param d1 Internal coefficient of Black-Scholes\\n   * @param d2 Internal coefficient of Black-Scholes\\n   */\\n  function _optionPrices(\\n    uint tAnnualised,\\n    uint spot,\\n    uint strikePrice,\\n    int rate,\\n    int d1,\\n    int d2\\n  ) internal pure returns (uint call, uint put) {\\n    uint strikePricePV = strikePrice.multiplyDecimalRoundPrecise(\\n      FixedPointMathLib.expPrecise(int(-rate.multiplyDecimalRoundPrecise(int(tAnnualised))))\\n    );\\n    uint spotNd1 = spot.multiplyDecimalRoundPrecise(_stdNormalCDF(d1));\\n    uint strikePriceNd2 = strikePricePV.multiplyDecimalRoundPrecise(_stdNormalCDF(d2));\\n\\n    // We clamp to zero if the minuend is less than the subtrahend\\n    // In some scenarios it may be better to compute put price instead and derive call from it depending on which way\\n    // around is more precise.\\n    call = strikePriceNd2 <= spotNd1 ? spotNd1 - strikePriceNd2 : 0;\\n    put = call + strikePricePV;\\n    put = spot <= put ? put - spot : 0;\\n  }\\n\\n  /*\\n   * Greeks\\n   */\\n\\n  /**\\n   * @dev Returns the option's delta value\\n   * @param d1 Internal coefficient of Black-Scholes\\n   */\\n  function _delta(int d1) internal pure returns (int callDelta, int putDelta) {\\n    callDelta = int(_stdNormalCDF(d1));\\n    putDelta = callDelta - int(PRECISE_UNIT);\\n  }\\n\\n  /**\\n   * @dev Returns the option's vega value based on d1. Quoted in cents.\\n   *\\n   * @param d1 Internal coefficient of Black-Scholes\\n   * @param tAnnualised Number of years to expiry\\n   * @param spot The current price of the base asset\\n   */\\n  function _vega(uint tAnnualised, uint spot, int d1) internal pure returns (uint) {\\n    return _sqrtPrecise(tAnnualised).multiplyDecimalRoundPrecise(_stdNormal(d1).multiplyDecimalRoundPrecise(spot));\\n  }\\n\\n  /**\\n   * @dev Returns the option's vega value with expiry modified to be at least VEGA_STANDARDISATION_MIN_DAYS\\n   * @param d1 Internal coefficient of Black-Scholes\\n   * @param spot The current price of the base asset\\n   * @param timeToExpirySec Number of seconds to expiry\\n   */\\n  function _standardVega(int d1, uint spot, uint timeToExpirySec) internal pure returns (uint, uint) {\\n    uint tAnnualised = _annualise(timeToExpirySec);\\n    uint normalisationFactor = _getVegaNormalisationFactorPrecise(timeToExpirySec);\\n    uint vegaPrecise = _vega(tAnnualised, spot, d1);\\n    return (vegaPrecise, vegaPrecise.multiplyDecimalRoundPrecise(normalisationFactor));\\n  }\\n\\n  function _getVegaNormalisationFactorPrecise(uint timeToExpirySec) internal pure returns (uint) {\\n    timeToExpirySec = timeToExpirySec < VEGA_STANDARDISATION_MIN_DAYS ? VEGA_STANDARDISATION_MIN_DAYS : timeToExpirySec;\\n    uint daysToExpiry = timeToExpirySec / 1 days;\\n    uint thirty = 30 * PRECISE_UNIT;\\n    return _sqrtPrecise(thirty / daysToExpiry) / 100;\\n  }\\n\\n  /////////////////////\\n  // Math Operations //\\n  /////////////////////\\n\\n  /// @notice Calculates the square root of x, rounding down (borrowed from https://github.com/paulrberg/prb-math)\\n  /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n  /// @param x The uint256 number for which to calculate the square root.\\n  /// @return result The result as an uint256.\\n  function _sqrt(uint x) internal pure returns (uint result) {\\n    if (x == 0) {\\n      return 0;\\n    }\\n\\n    // Calculate the square root of the perfect square of a power of two that is the closest to x.\\n    uint xAux = uint(x);\\n    result = 1;\\n    if (xAux >= 0x100000000000000000000000000000000) {\\n      xAux >>= 128;\\n      result <<= 64;\\n    }\\n    if (xAux >= 0x10000000000000000) {\\n      xAux >>= 64;\\n      result <<= 32;\\n    }\\n    if (xAux >= 0x100000000) {\\n      xAux >>= 32;\\n      result <<= 16;\\n    }\\n    if (xAux >= 0x10000) {\\n      xAux >>= 16;\\n      result <<= 8;\\n    }\\n    if (xAux >= 0x100) {\\n      xAux >>= 8;\\n      result <<= 4;\\n    }\\n    if (xAux >= 0x10) {\\n      xAux >>= 4;\\n      result <<= 2;\\n    }\\n    if (xAux >= 0x8) {\\n      result <<= 1;\\n    }\\n\\n    // The operations can never overflow because the result is max 2^127 when it enters this block.\\n    unchecked {\\n      result = (result + x / result) >> 1;\\n      result = (result + x / result) >> 1;\\n      result = (result + x / result) >> 1;\\n      result = (result + x / result) >> 1;\\n      result = (result + x / result) >> 1;\\n      result = (result + x / result) >> 1;\\n      result = (result + x / result) >> 1; // Seven iterations should be enough\\n      uint roundedDownResult = x / result;\\n      return result >= roundedDownResult ? roundedDownResult : result;\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the square root of the value using Newton's method.\\n   */\\n  function _sqrtPrecise(uint x) internal pure returns (uint) {\\n    // Add in an extra unit factor for the square root to gobble;\\n    // otherwise, sqrt(x * UNIT) = sqrt(x) * sqrt(UNIT)\\n    return _sqrt(x * PRECISE_UNIT);\\n  }\\n\\n  /**\\n   * @dev The standard normal distribution of the value.\\n   */\\n  function _stdNormal(int x) internal pure returns (uint) {\\n    return\\n      FixedPointMathLib.expPrecise(int(-x.multiplyDecimalRoundPrecise(x / 2))).divideDecimalRoundPrecise(SQRT_TWOPI);\\n  }\\n\\n  /**\\n   * @dev The standard normal cumulative distribution of the value.\\n   * borrowed from a C++ implementation https://stackoverflow.com/a/23119456\\n   */\\n  function _stdNormalCDF(int x) public pure returns (uint) {\\n    uint z = Math.abs(x);\\n    int c = 0;\\n\\n    if (z <= 37 * PRECISE_UNIT) {\\n      uint e = FixedPointMathLib.expPrecise(-int(z.multiplyDecimalRoundPrecise(z / 2)));\\n      if (z < SPLIT) {\\n        c = int(\\n          (_stdNormalCDFNumerator(z).divideDecimalRoundPrecise(_stdNormalCDFDenom(z)).multiplyDecimalRoundPrecise(e))\\n        );\\n      } else {\\n        uint f = (z +\\n          PRECISE_UNIT.divideDecimalRoundPrecise(\\n            z +\\n              (2 * PRECISE_UNIT).divideDecimalRoundPrecise(\\n                z +\\n                  (3 * PRECISE_UNIT).divideDecimalRoundPrecise(\\n                    z + (4 * PRECISE_UNIT).divideDecimalRoundPrecise(z + ((PRECISE_UNIT * 13) / 20))\\n                  )\\n              )\\n          ));\\n        c = int(e.divideDecimalRoundPrecise(f.multiplyDecimalRoundPrecise(SQRT_TWOPI)));\\n      }\\n    }\\n    return uint((x <= 0 ? c : (int(PRECISE_UNIT) - c)));\\n  }\\n\\n  /**\\n   * @dev Helper for _stdNormalCDF\\n   */\\n  function _stdNormalCDFNumerator(uint z) internal pure returns (uint) {\\n    uint numeratorInner = ((((((N6 * z) / PRECISE_UNIT + N5) * z) / PRECISE_UNIT + N4) * z) / PRECISE_UNIT + N3);\\n    return (((((numeratorInner * z) / PRECISE_UNIT + N2) * z) / PRECISE_UNIT + N1) * z) / PRECISE_UNIT + N0;\\n  }\\n\\n  /**\\n   * @dev Helper for _stdNormalCDF\\n   */\\n  function _stdNormalCDFDenom(uint z) internal pure returns (uint) {\\n    uint denominatorInner = ((((((M7 * z) / PRECISE_UNIT + M6) * z) / PRECISE_UNIT + M5) * z) / PRECISE_UNIT + M4);\\n    return\\n      (((((((denominatorInner * z) / PRECISE_UNIT + M3) * z) / PRECISE_UNIT + M2) * z) / PRECISE_UNIT + M1) * z) /\\n      PRECISE_UNIT +\\n      M0;\\n  }\\n\\n  /**\\n   * @dev Converts an integer number of seconds to a fractional number of years.\\n   */\\n  function _annualise(uint secs) internal pure returns (uint yearFraction) {\\n    return secs.divideDecimalRoundPrecise(SECONDS_PER_YEAR);\\n  }\\n}\\n\",\"keccak256\":\"0x662dac00a0aefe3efe247244fd94b63e6f5e049c563bf88debf395e8ce125fc6\",\"license\":\"ISC\"},\"contracts/libraries/FixedPointMathLib.sol\":{\"content\":\"//SPDX-License-Identifier: ISC\\npragma solidity 0.8.16;\\n\\n// Slightly modified version of:\\n// - https://github.com/recmo/experiment-solexp/blob/605738f3ed72d6c67a414e992be58262fbc9bb80/src/FixedPointMathLib.sol\\nlibrary FixedPointMathLib {\\n  /// @dev Computes ln(x) for a 1e27 fixed point. Loses 9 last significant digits of precision.\\n  function lnPrecise(int x) internal pure returns (int r) {\\n    return ln(x / 1e9) * 1e9;\\n  }\\n\\n  /// @dev Computes e ^ x for a 1e27 fixed point. Loses 9 last significant digits of precision.\\n  function expPrecise(int x) internal pure returns (uint r) {\\n    return exp(x / 1e9) * 1e9;\\n  }\\n\\n  // Computes ln(x) in 1e18 fixed point.\\n  // Reverts if x is negative or zero.\\n  // Consumes 670 gas.\\n  function ln(int x) internal pure returns (int r) {\\n    unchecked {\\n      if (x < 1) {\\n        if (x < 0) revert LnNegativeUndefined();\\n        revert Overflow();\\n      }\\n\\n      // We want to convert x from 10**18 fixed point to 2**96 fixed point.\\n      // We do this by multiplying by 2**96 / 10**18.\\n      // But since ln(x * C) = ln(x) + ln(C), we can simply do nothing here\\n      // and add ln(2**96 / 10**18) at the end.\\n\\n      // Reduce range of x to (1, 2) * 2**96\\n      // ln(2^k * x) = k * ln(2) + ln(x)\\n      // Note: inlining ilog2 saves 8 gas.\\n      int k = int(ilog2(uint(x))) - 96;\\n      x <<= uint(159 - k);\\n      x = int(uint(x) >> 159);\\n\\n      // Evaluate using a (8, 8)-term rational approximation\\n      // p is made monic, we will multiply by a scale factor later\\n      int p = x + 3273285459638523848632254066296;\\n      p = ((p * x) >> 96) + 24828157081833163892658089445524;\\n      p = ((p * x) >> 96) + 43456485725739037958740375743393;\\n      p = ((p * x) >> 96) - 11111509109440967052023855526967;\\n      p = ((p * x) >> 96) - 45023709667254063763336534515857;\\n      p = ((p * x) >> 96) - 14706773417378608786704636184526;\\n      p = p * x - (795164235651350426258249787498 << 96);\\n      //emit log_named_int(\\\"p\\\", p);\\n      // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n      // q is monic by convention\\n      int q = x + 5573035233440673466300451813936;\\n      q = ((q * x) >> 96) + 71694874799317883764090561454958;\\n      q = ((q * x) >> 96) + 283447036172924575727196451306956;\\n      q = ((q * x) >> 96) + 401686690394027663651624208769553;\\n      q = ((q * x) >> 96) + 204048457590392012362485061816622;\\n      q = ((q * x) >> 96) + 31853899698501571402653359427138;\\n      q = ((q * x) >> 96) + 909429971244387300277376558375;\\n      assembly {\\n        // Div in assembly because solidity adds a zero check despite the `unchecked`.\\n        // The q polynomial is known not to have zeros in the domain. (All roots are complex)\\n        // No scaling required because p is already 2**96 too large.\\n        r := sdiv(p, q)\\n      }\\n      // r is in the range (0, 0.125) * 2**96\\n\\n      // Finalization, we need to\\n      // * multiply by the scale factor s = 5.549\\u2026\\n      // * add ln(2**96 / 10**18)\\n      // * add k * ln(2)\\n      // * multiply by 10**18 / 2**96 = 5**18 >> 78\\n      // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\\n      r *= 1677202110996718588342820967067443963516166;\\n      // add ln(2) * k * 5e18 * 2**192\\n      r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\\n      // add ln(2**96 / 10**18) * 5e18 * 2**192\\n      r += 600920179829731861736702779321621459595472258049074101567377883020018308;\\n      // base conversion: mul 2**18 / 2**192\\n      r >>= 174;\\n    }\\n  }\\n\\n  // Integer log2\\n  // @returns floor(log2(x)) if x is nonzero, otherwise 0. This is the same\\n  //          as the location of the highest set bit.\\n  // Consumes 232 gas. This could have been an 3 gas EVM opcode though.\\n  function ilog2(uint x) internal pure returns (uint r) {\\n    assembly {\\n      r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n      r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n      r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n      r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n      r := or(r, shl(3, lt(0xff, shr(r, x))))\\n      r := or(r, shl(2, lt(0xf, shr(r, x))))\\n      r := or(r, shl(1, lt(0x3, shr(r, x))))\\n      r := or(r, lt(0x1, shr(r, x)))\\n    }\\n  }\\n\\n  // Computes e^x in 1e18 fixed point.\\n  function exp(int x) internal pure returns (uint r) {\\n    unchecked {\\n      // Input x is in fixed point format, with scale factor 1/1e18.\\n\\n      // When the result is < 0.5 we return zero. This happens when\\n      // x <= floor(log(0.5e18) * 1e18) ~ -42e18\\n      if (x <= -42139678854452767551) {\\n        return 0;\\n      }\\n\\n      // When the result is > (2**255 - 1) / 1e18 we can not represent it\\n      // as an int256. This happens when x >= floor(log((2**255 -1) / 1e18) * 1e18) ~ 135.\\n      if (x >= 135305999368893231589) revert ExpOverflow();\\n\\n      // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\\n      // for more intermediate precision and a binary basis. This base conversion\\n      // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\\n      x = (x << 78) / 5 ** 18;\\n\\n      // Reduce range of x to (-\\u00bd ln 2, \\u00bd ln 2) * 2**96 by factoring out powers of two\\n      // such that exp(x) = exp(x') * 2**k, where k is an integer.\\n      // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\\n      int k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\\n      x = x - k * 54916777467707473351141471128;\\n      // k is in the range [-61, 195].\\n\\n      // Evaluate using a (6, 7)-term rational approximation\\n      // p is made monic, we will multiply by a scale factor later\\n      int p = x + 2772001395605857295435445496992;\\n      p = ((p * x) >> 96) + 44335888930127919016834873520032;\\n      p = ((p * x) >> 96) + 398888492587501845352592340339721;\\n      p = ((p * x) >> 96) + 1993839819670624470859228494792842;\\n      p = p * x + (4385272521454847904632057985693276 << 96);\\n      // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n      // Evaluate using using Knuth's scheme from p. 491.\\n      int z = x + 750530180792738023273180420736;\\n      z = ((z * x) >> 96) + 32788456221302202726307501949080;\\n      int w = x - 2218138959503481824038194425854;\\n      w = ((w * z) >> 96) + 892943633302991980437332862907700;\\n      int q = z + w - 78174809823045304726920794422040;\\n      q = ((q * w) >> 96) + 4203224763890128580604056984195872;\\n      assembly {\\n        // Div in assembly because solidity adds a zero check despite the `unchecked`.\\n        // The q polynomial is known not to have zeros in the domain. (All roots are complex)\\n        // No scaling required because p is already 2**96 too large.\\n        r := sdiv(p, q)\\n      }\\n      // r should be in the range (0.09, 0.25) * 2**96.\\n\\n      // We now need to multiply r by\\n      //  * the scale factor s = ~6.031367120...,\\n      //  * the 2**k factor from the range reduction, and\\n      //  * the 1e18 / 2**96 factor for base converison.\\n      // We do all of this at once, with an intermediate result in 2**213 basis\\n      // so the final right shift is always by a positive amount.\\n      r = (uint(r) * 3822833074963236453042738258902158003155416615667) >> uint(195 - k);\\n    }\\n  }\\n\\n  error Overflow();\\n  error ExpOverflow();\\n  error LnNegativeUndefined();\\n}\\n\",\"keccak256\":\"0x420f0263c88795a0928131644fa0963cc658847520e19e5b6f7dc3c1c1934d44\",\"license\":\"ISC\"},\"contracts/libraries/Math.sol\":{\"content\":\"//SPDX-License-Identifier: ISC\\npragma solidity 0.8.16;\\n\\n/**\\n * @title Math\\n * @author Lyra\\n * @dev Library to unify logic for common shared functions\\n */\\nlibrary Math {\\n  /// @dev Return the minimum value between the two inputs\\n  function min(uint x, uint y) internal pure returns (uint) {\\n    return (x < y) ? x : y;\\n  }\\n\\n  /// @dev Return the maximum value between the two inputs\\n  function max(uint x, uint y) internal pure returns (uint) {\\n    return (x > y) ? x : y;\\n  }\\n\\n  /// @dev Compute the absolute value of `val`.\\n  function abs(int val) internal pure returns (uint) {\\n    return uint(val < 0 ? -val : val);\\n  }\\n\\n  /// @dev Takes ceiling of a to m precision\\n  /// @param m represents 1eX where X is the number of trailing 0's\\n  function ceil(uint a, uint m) internal pure returns (uint) {\\n    return ((a + m - 1) / m) * m;\\n  }\\n}\\n\",\"keccak256\":\"0xcad8d50c98a7dbcc9c5be9f872e96309dca883a4b0fab5533f2882dcf03a98b5\",\"license\":\"ISC\"},\"contracts/synthetix/DecimalMath.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\n//\\n//Copyright (c) 2019 Synthetix\\n//\\n//Permission is hereby granted, free of charge, to any person obtaining a copy\\n//of this software and associated documentation files (the \\\"Software\\\"), to deal\\n//in the Software without restriction, including without limitation the rights\\n//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n//copies of the Software, and to permit persons to whom the Software is\\n//furnished to do so, subject to the following conditions:\\n//\\n//The above copyright notice and this permission notice shall be included in all\\n//copies or substantial portions of the Software.\\n//\\n//THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n//SOFTWARE.\\n\\npragma solidity 0.8.16;\\n\\n/**\\n * @title DecimalMath\\n * @author Lyra\\n * @dev Modified synthetix SafeDecimalMath to include internal arithmetic underflow/overflow.\\n * @dev https://docs.synthetix.io/contracts/source/libraries/SafeDecimalMath/\\n */\\n\\nlibrary DecimalMath {\\n  /* Number of decimal places in the representations. */\\n  uint8 public constant decimals = 18;\\n  uint8 public constant highPrecisionDecimals = 27;\\n\\n  /* The number representing 1.0. */\\n  uint public constant UNIT = 10 ** uint(decimals);\\n\\n  /* The number representing 1.0 for higher fidelity numbers. */\\n  uint public constant PRECISE_UNIT = 10 ** uint(highPrecisionDecimals);\\n  uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10 ** uint(highPrecisionDecimals - decimals);\\n\\n  /**\\n   * @return Provides an interface to UNIT.\\n   */\\n  function unit() external pure returns (uint) {\\n    return UNIT;\\n  }\\n\\n  /**\\n   * @return Provides an interface to PRECISE_UNIT.\\n   */\\n  function preciseUnit() external pure returns (uint) {\\n    return PRECISE_UNIT;\\n  }\\n\\n  /**\\n   * @return The result of multiplying x and y, interpreting the operands as fixed-point\\n   * decimals.\\n   *\\n   * @dev A unit factor is divided out after the product of x and y is evaluated,\\n   * so that product must be less than 2**256. As this is an integer division,\\n   * the internal division always rounds down. This helps save on gas. Rounding\\n   * is more expensive on gas.\\n   */\\n  function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\\n    /* Divide by UNIT to remove the extra factor introduced by the product. */\\n    return (x * y) / UNIT;\\n  }\\n\\n  /**\\n   * @return The result of safely multiplying x and y, interpreting the operands\\n   * as fixed-point decimals of the specified precision unit.\\n   *\\n   * @dev The operands should be in the form of a the specified unit factor which will be\\n   * divided out after the product of x and y is evaluated, so that product must be\\n   * less than 2**256.\\n   *\\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\\n   * (eg. small fractions or percentages).\\n   */\\n  function _multiplyDecimalRound(uint x, uint y, uint precisionUnit) private pure returns (uint) {\\n    /* Divide by UNIT to remove the extra factor introduced by the product. */\\n    uint quotientTimesTen = (x * y) / (precisionUnit / 10);\\n\\n    if (quotientTimesTen % 10 >= 5) {\\n      quotientTimesTen += 10;\\n    }\\n\\n    return quotientTimesTen / 10;\\n  }\\n\\n  /**\\n   * @return The result of safely multiplying x and y, interpreting the operands\\n   * as fixed-point decimals of a precise unit.\\n   *\\n   * @dev The operands should be in the precise unit factor which will be\\n   * divided out after the product of x and y is evaluated, so that product must be\\n   * less than 2**256.\\n   *\\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\\n   * (eg. small fractions or percentages).\\n   */\\n  function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\\n    return _multiplyDecimalRound(x, y, PRECISE_UNIT);\\n  }\\n\\n  /**\\n   * @return The result of safely multiplying x and y, interpreting the operands\\n   * as fixed-point decimals of a standard unit.\\n   *\\n   * @dev The operands should be in the standard unit factor which will be\\n   * divided out after the product of x and y is evaluated, so that product must be\\n   * less than 2**256.\\n   *\\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\\n   * (eg. small fractions or percentages).\\n   */\\n  function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\\n    return _multiplyDecimalRound(x, y, UNIT);\\n  }\\n\\n  /**\\n   * @return The result of safely dividing x and y. The return value is a high\\n   * precision decimal.\\n   *\\n   * @dev y is divided after the product of x and the standard precision unit\\n   * is evaluated, so the product of x and UNIT must be less than 2**256. As\\n   * this is an integer division, the result is always rounded down.\\n   * This helps save on gas. Rounding is more expensive on gas.\\n   */\\n  function divideDecimal(uint x, uint y) internal pure returns (uint) {\\n    /* Reintroduce the UNIT factor that will be divided out by y. */\\n    return (x * UNIT) / y;\\n  }\\n\\n  /**\\n   * @return The result of safely dividing x and y. The return value is as a rounded\\n   * decimal in the precision unit specified in the parameter.\\n   *\\n   * @dev y is divided after the product of x and the specified precision unit\\n   * is evaluated, so the product of x and the specified precision unit must\\n   * be less than 2**256. The result is rounded to the nearest increment.\\n   */\\n  function _divideDecimalRound(uint x, uint y, uint precisionUnit) private pure returns (uint) {\\n    uint resultTimesTen = (x * (precisionUnit * 10)) / y;\\n\\n    if (resultTimesTen % 10 >= 5) {\\n      resultTimesTen += 10;\\n    }\\n\\n    return resultTimesTen / 10;\\n  }\\n\\n  /**\\n   * @return The result of safely dividing x and y. The return value is as a rounded\\n   * standard precision decimal.\\n   *\\n   * @dev y is divided after the product of x and the standard precision unit\\n   * is evaluated, so the product of x and the standard precision unit must\\n   * be less than 2**256. The result is rounded to the nearest increment.\\n   */\\n  function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\\n    return _divideDecimalRound(x, y, UNIT);\\n  }\\n\\n  /**\\n   * @return The result of safely dividing x and y. The return value is as a rounded\\n   * high precision decimal.\\n   *\\n   * @dev y is divided after the product of x and the high precision unit\\n   * is evaluated, so the product of x and the high precision unit must\\n   * be less than 2**256. The result is rounded to the nearest increment.\\n   */\\n  function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\\n    return _divideDecimalRound(x, y, PRECISE_UNIT);\\n  }\\n\\n  /**\\n   * @dev Convert a standard decimal representation to a high precision one.\\n   */\\n  function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\\n    return i * UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR;\\n  }\\n\\n  /**\\n   * @dev Convert a high precision decimal to a standard decimal representation.\\n   */\\n  function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\\n    uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\\n\\n    if (quotientTimesTen % 10 >= 5) {\\n      quotientTimesTen += 10;\\n    }\\n\\n    return quotientTimesTen / 10;\\n  }\\n}\\n\",\"keccak256\":\"0xfc2b3daab71759952c0b477d623d4c82f92fed3ed28944e2fbd05fc7c3de51fd\",\"license\":\"MIT\"},\"contracts/synthetix/SignedDecimalMath.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\n//\\n//Copyright (c) 2019 Synthetix\\n//\\n//Permission is hereby granted, free of charge, to any person obtaining a copy\\n//of this software and associated documentation files (the \\\"Software\\\"), to deal\\n//in the Software without restriction, including without limitation the rights\\n//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n//copies of the Software, and to permit persons to whom the Software is\\n//furnished to do so, subject to the following conditions:\\n//\\n//The above copyright notice and this permission notice shall be included in all\\n//copies or substantial portions of the Software.\\n//\\n//THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n//SOFTWARE.\\n\\npragma solidity 0.8.16;\\n\\n/**\\n * @title SignedDecimalMath\\n * @author Lyra\\n * @dev Modified synthetix SafeSignedDecimalMath to include internal arithmetic underflow/overflow.\\n * @dev https://docs.synthetix.io/contracts/source/libraries/safedecimalmath\\n */\\nlibrary SignedDecimalMath {\\n  /* Number of decimal places in the representations. */\\n  uint8 public constant decimals = 18;\\n  uint8 public constant highPrecisionDecimals = 27;\\n\\n  /* The number representing 1.0. */\\n  int public constant UNIT = int(10 ** uint(decimals));\\n\\n  /* The number representing 1.0 for higher fidelity numbers. */\\n  int public constant PRECISE_UNIT = int(10 ** uint(highPrecisionDecimals));\\n  int private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = int(10 ** uint(highPrecisionDecimals - decimals));\\n\\n  /**\\n   * @return Provides an interface to UNIT.\\n   */\\n  function unit() external pure returns (int) {\\n    return UNIT;\\n  }\\n\\n  /**\\n   * @return Provides an interface to PRECISE_UNIT.\\n   */\\n  function preciseUnit() external pure returns (int) {\\n    return PRECISE_UNIT;\\n  }\\n\\n  /**\\n   * @dev Rounds an input with an extra zero of precision, returning the result without the extra zero.\\n   * Half increments round away from zero; positive numbers at a half increment are rounded up,\\n   * while negative such numbers are rounded down. This behaviour is designed to be consistent with the\\n   * unsigned version of this library (SafeDecimalMath).\\n   */\\n  function _roundDividingByTen(int valueTimesTen) private pure returns (int) {\\n    int increment;\\n    if (valueTimesTen % 10 >= 5) {\\n      increment = 10;\\n    } else if (valueTimesTen % 10 <= -5) {\\n      increment = -10;\\n    }\\n    return (valueTimesTen + increment) / 10;\\n  }\\n\\n  /**\\n   * @return The result of multiplying x and y, interpreting the operands as fixed-point\\n   * decimals.\\n   *\\n   * @dev A unit factor is divided out after the product of x and y is evaluated,\\n   * so that product must be less than 2**256. As this is an integer division,\\n   * the internal division always rounds down. This helps save on gas. Rounding\\n   * is more expensive on gas.\\n   */\\n  function multiplyDecimal(int x, int y) internal pure returns (int) {\\n    /* Divide by UNIT to remove the extra factor introduced by the product. */\\n    return (x * y) / UNIT;\\n  }\\n\\n  /**\\n   * @return The result of safely multiplying x and y, interpreting the operands\\n   * as fixed-point decimals of the specified precision unit.\\n   *\\n   * @dev The operands should be in the form of a the specified unit factor which will be\\n   * divided out after the product of x and y is evaluated, so that product must be\\n   * less than 2**256.\\n   *\\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\\n   * (eg. small fractions or percentages).\\n   */\\n  function _multiplyDecimalRound(int x, int y, int precisionUnit) private pure returns (int) {\\n    /* Divide by UNIT to remove the extra factor introduced by the product. */\\n    int quotientTimesTen = (x * y) / (precisionUnit / 10);\\n    return _roundDividingByTen(quotientTimesTen);\\n  }\\n\\n  /**\\n   * @return The result of safely multiplying x and y, interpreting the operands\\n   * as fixed-point decimals of a precise unit.\\n   *\\n   * @dev The operands should be in the precise unit factor which will be\\n   * divided out after the product of x and y is evaluated, so that product must be\\n   * less than 2**256.\\n   *\\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\\n   * (eg. small fractions or percentages).\\n   */\\n  function multiplyDecimalRoundPrecise(int x, int y) internal pure returns (int) {\\n    return _multiplyDecimalRound(x, y, PRECISE_UNIT);\\n  }\\n\\n  /**\\n   * @return The result of safely multiplying x and y, interpreting the operands\\n   * as fixed-point decimals of a standard unit.\\n   *\\n   * @dev The operands should be in the standard unit factor which will be\\n   * divided out after the product of x and y is evaluated, so that product must be\\n   * less than 2**256.\\n   *\\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\\n   * (eg. small fractions or percentages).\\n   */\\n  function multiplyDecimalRound(int x, int y) internal pure returns (int) {\\n    return _multiplyDecimalRound(x, y, UNIT);\\n  }\\n\\n  /**\\n   * @return The result of safely dividing x and y. The return value is a high\\n   * precision decimal.\\n   *\\n   * @dev y is divided after the product of x and the standard precision unit\\n   * is evaluated, so the product of x and UNIT must be less than 2**256. As\\n   * this is an integer division, the result is always rounded down.\\n   * This helps save on gas. Rounding is more expensive on gas.\\n   */\\n  function divideDecimal(int x, int y) internal pure returns (int) {\\n    /* Reintroduce the UNIT factor that will be divided out by y. */\\n    return (x * UNIT) / y;\\n  }\\n\\n  /**\\n   * @return The result of safely dividing x and y. The return value is as a rounded\\n   * decimal in the precision unit specified in the parameter.\\n   *\\n   * @dev y is divided after the product of x and the specified precision unit\\n   * is evaluated, so the product of x and the specified precision unit must\\n   * be less than 2**256. The result is rounded to the nearest increment.\\n   */\\n  function _divideDecimalRound(int x, int y, int precisionUnit) private pure returns (int) {\\n    int resultTimesTen = (x * (precisionUnit * 10)) / y;\\n    return _roundDividingByTen(resultTimesTen);\\n  }\\n\\n  /**\\n   * @return The result of safely dividing x and y. The return value is as a rounded\\n   * standard precision decimal.\\n   *\\n   * @dev y is divided after the product of x and the standard precision unit\\n   * is evaluated, so the product of x and the standard precision unit must\\n   * be less than 2**256. The result is rounded to the nearest increment.\\n   */\\n  function divideDecimalRound(int x, int y) internal pure returns (int) {\\n    return _divideDecimalRound(x, y, UNIT);\\n  }\\n\\n  /**\\n   * @return The result of safely dividing x and y. The return value is as a rounded\\n   * high precision decimal.\\n   *\\n   * @dev y is divided after the product of x and the high precision unit\\n   * is evaluated, so the product of x and the high precision unit must\\n   * be less than 2**256. The result is rounded to the nearest increment.\\n   */\\n  function divideDecimalRoundPrecise(int x, int y) internal pure returns (int) {\\n    return _divideDecimalRound(x, y, PRECISE_UNIT);\\n  }\\n\\n  /**\\n   * @dev Convert a standard decimal representation to a high precision one.\\n   */\\n  function decimalToPreciseDecimal(int i) internal pure returns (int) {\\n    return i * UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR;\\n  }\\n\\n  /**\\n   * @dev Convert a high precision decimal to a standard decimal representation.\\n   */\\n  function preciseDecimalToDecimal(int i) internal pure returns (int) {\\n    int quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\\n    return _roundDividingByTen(quotientTimesTen);\\n  }\\n}\\n\",\"keccak256\":\"0x972b430038cc43e8b26139361eb33a2f11f2d58f57154328a339df113bd31986\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b5060405162003a7538038062003a758339818101604052810190620000379190620001f0565b846000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555083600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555082600260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555081600360006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555080600460006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550505050505062000278565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000620001b8826200018b565b9050919050565b620001ca81620001ab565b8114620001d657600080fd5b50565b600081519050620001ea81620001bf565b92915050565b600080600080600060a086880312156200020f576200020e62000186565b5b60006200021f88828901620001d9565b95505060206200023288828901620001d9565b94505060406200024588828901620001d9565b93505060606200025888828901620001d9565b92505060806200026b88828901620001d9565b9150509295509295909350565b6137ed80620002886000396000f3fe608060405234801561001057600080fd5b50600436106100cf5760003560e01c8063a2d804ee1161008c578063b65f4b2a11610066578063b65f4b2a1461024e578063bb4a9f881461027e578063ddfaeb771461029c578063f918b32b146102cc576100cf565b8063a2d804ee146101d0578063a5a249d014610200578063a827e8861461021e576100cf565b8063183a3dfa146100d457806333994cd7146100f257806357193101146101225780635bc8ccc214610152578063665a11ca146101825780638557d638146101a0575b600080fd5b6100dc6102ea565b6040516100e99190611550565b60405180910390f35b61010c600480360381019061010791906115b5565b610310565b6040516101199190611617565b60405180910390f35b61013c600480360381019061013791906117c3565b610489565b6040516101499190611617565b60405180910390f35b61016c60048036038101906101679190611b9f565b610518565b6040516101799190611ca9565b60405180910390f35b61018a6106ae565b6040516101979190611ce5565b60405180910390f35b6101ba60048036038101906101b59190611de0565b6106d4565b6040516101c79190611ef5565b60405180910390f35b6101ea60048036038101906101e59190611f10565b6108ab565b6040516101f79190611617565b60405180910390f35b610208610a11565b6040516102159190611f71565b60405180910390f35b61023860048036038101906102339190611fe9565b610a37565b6040516102459190611617565b60405180910390f35b61026860048036038101906102639190612076565b610f16565b6040516102759190612304565b60405180910390f35b610286611068565b6040516102939190612341565b60405180910390f35b6102b660048036038101906102b1919061235c565b61108c565b6040516102c39190611617565b60405180910390f35b6102d4611277565b6040516102e191906123d0565b60405180910390f35b600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600080600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16636f2fddc66040518163ffffffff1660e01b815260040161012060405180830381865afa158015610381573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103a591906124e0565b90506000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d44558d28584608001518560a0015186606001516040518563ffffffff1660e01b8152600401610416949392919061250e565b602060405180830381865afa158015610433573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104579190612553565b905061047e85610470888461129d90919063ffffffff16565b61129d90919063ffffffff16565b925050509392505050565b600080600160048111156104a05761049f612100565b5b8560048111156104b3576104b2612100565b5b141580156104e557506004808111156104cf576104ce612100565b5b8560048111156104e2576104e1612100565b5b14155b6104f35782602001516104f9565b82600001515b905061050e848261129d90919063ffffffff16565b9150509392505050565b6105206113a7565b6040518060a0016040528061053884604001516112ce565b81526020016105588560600151856060015161129d90919063ffffffff16565b815260200185815260200184604001518152602001600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16634a51c00960008054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518263ffffffff1660e01b81526004016105e891906125a1565b602060405180830381865afa158015610605573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061062991906125d1565b81525073EAC659b8e6458568D84A278d1a1b286DD1e9511B63036d587890916040518263ffffffff1660e01b81526004016106649190612684565b60c060405180830381865af4158015610681573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106a5919061273f565b90509392505050565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6106dc6113dd565b6000600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16636461a97b6040518163ffffffff1660e01b815260040161010060405180830381865afa15801561074c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107709190612871565b905060006107908760a00151886080015161078b91906128ce565b6112e1565b61079d88606001516112e1565b6107a79190612902565b905060006107b88860e001516112e1565b6107c58960c001516112e1565b6107cf9190612902565b9050600061081f6107e78960800151604001516112e1565b8960c001518a60a0015185876107fd9190612945565b6108079190612902565b6108119190612902565b61134e90919063ffffffff16565b90508360a001516020015161083390612989565b856020018181525050808460a001516020015161084f90612989565b6108599190612945565b85604001818152505061087d8860600151886060015161129d90919063ffffffff16565b856080018181525050858560c00181815250508661010001518560a001818152505050505050949350505050565b600080600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16636f2fddc66040518163ffffffff1660e01b815260040161012060405180830381865afa15801561091c573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061094091906124e0565b90506000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d44558d2858460200151856040015186600001516040518563ffffffff1660e01b81526004016109b1949392919061250e565b602060405180830381865afa1580156109ce573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109f29190612553565b9050610a07858261129d90919063ffffffff16565b9250505092915050565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600080610a478585898987610f16565b905060008060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663c4c4a0d08b6040518263ffffffff1660e01b8152600401610aa59190611617565b600060405180830381865afa158015610ac2573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f82011682018060405250810190610aeb9190612c05565b915091506000600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663641c37368c6040518263ffffffff1660e01b8152600401610b4c9190611617565b61018060405180830381865afa158015610b6a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b8e9190612dbc565b90506000600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16637fdf17e283602001516040518263ffffffff1660e01b8152600401610bf19190611617565b600060405180830381865afa158015610c0e573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f82011682018060405250810190610c379190612ee8565b90506000610c4a8660e001518484610518565b90506000610c5e86858585608001516106d4565b90506000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166331adee8e8986606001518a604001516040518463ffffffff1660e01b8152600401610cc993929190612f31565b6040805180830381865afa158015610ce5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d099190612f6b565b9150506000610d198e8e86610489565b90506000610d2b8289602001516108ab565b90506000610d468b60e001518c608001518b60200151610310565b90506000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16638e8fd8b98d886040518363ffffffff1660e01b8152600401610da7929190612fab565b60c060405180830381865afa158015610dc4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610de89190613076565b90506000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663140c12578e89896040518463ffffffff1660e01b8152600401610e4b939291906130a3565b61010060405180830381865afa158015610e69573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e8d91906131a7565b905060008160e001518360a001518587610ea791906128ce565b610eb191906128ce565b610ebb91906128ce565b90508d6000015115610eda578086610ed391906128ce565b9e50610efe565b85811115610eee5785905060009e50610efd565b8086610efa91906131d5565b9e505b5b50505050505050505050505050509695505050505050565b610f1e61141a565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630910a5106040518163ffffffff1660e01b815260040160e060405180830381865afa158015610f8b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610faf91906132bd565b60a0015181610100015160a0018181525050858160800181815250508181602001901515908115158152505084816000019015159081151581525050610ff684848461108c565b8160e0018181525050828160600190600481111561101757611016612100565b5b9081600481111561102b5761102a612100565b5b81525050838160400190600281111561104757611046612100565b5b9081600281111561105b5761105a612100565b5b8152505095945050505050565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000806002808111156110a2576110a1612100565b5b8560028111156110b5576110b4612100565b5b036110c357600290506111af565b600060048111156110d7576110d6612100565b5b8460048111156110ea576110e9612100565b5b1480611119575060048081111561110457611103612100565b5b84600481111561111757611116612100565b5b145b15611168576000600281111561113257611131612100565b5b85600281111561114557611144612100565b5b1461115e5782611156576000611159565b60035b611161565b60015b90506111ae565b6000600281111561117c5761117b612100565b5b85600281111561118f5761118e612100565b5b146111a857826111a05760016111a3565b60045b6111ab565b60005b90505b5b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166373cbfc6960008054906101000a900473ffffffffffffffffffffffffffffffffffffffff16836040518363ffffffff1660e01b815260040161122c929190613332565b602060405180830381865afa158015611249573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061126d9190612553565b9150509392505050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000601260ff16600a6112b0919061348e565b82846112bc91906134d9565b6112c69190613562565b905092915050565b60006112da428361137f565b9050919050565b60007f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821115611346576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161133d90613616565b60405180910390fd5b819050919050565b6000601260ff16600a611361919061348e565b828461136d9190613636565b611377919061374d565b905092915050565b60008282111561139c57828261139591906131d5565b90506113a1565b600090505b92915050565b6040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6040518060e00160405280600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6040518061012001604052806000151581526020016000151581526020016000600281111561144c5761144b612100565b5b81526020016000600481111561146557611464612100565b5b81526020016000815260200160008152602001600081526020016000815260200161148e611494565b81525090565b6040518060e00160405280600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b600061151661151161150c846114d1565b6114f1565b6114d1565b9050919050565b6000611528826114fb565b9050919050565b600061153a8261151d565b9050919050565b61154a8161152f565b82525050565b60006020820190506115656000830184611541565b92915050565b6000604051905090565b600080fd5b600080fd5b6000819050919050565b6115928161157f565b811461159d57600080fd5b50565b6000813590506115af81611589565b92915050565b6000806000606084860312156115ce576115cd611575565b5b60006115dc868287016115a0565b93505060206115ed868287016115a0565b92505060406115fe868287016115a0565b9150509250925092565b6116118161157f565b82525050565b600060208201905061162c6000830184611608565b92915050565b6005811061163f57600080fd5b50565b60008135905061165181611632565b92915050565b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6116a58261165c565b810181811067ffffffffffffffff821117156116c4576116c361166d565b5b80604052505050565b60006116d761156b565b90506116e3828261169c565b919050565b600080fd5b6000819050919050565b611700816116ed565b811461170b57600080fd5b50565b60008135905061171d816116f7565b92915050565b600060c0828403121561173957611738611657565b5b61174360c06116cd565b90506000611753848285016115a0565b6000830152506020611767848285016115a0565b602083015250604061177b8482850161170e565b604083015250606061178f8482850161170e565b60608301525060806117a3848285016115a0565b60808301525060a06117b7848285016115a0565b60a08301525092915050565b600080600061010084860312156117dd576117dc611575565b5b60006117eb86828701611642565b93505060206117fc868287016115a0565b925050604061180d86828701611723565b9150509250925092565b600060a0828403121561182d5761182c611657565b5b61183760a06116cd565b905060006118478482850161170e565b600083015250602061185b8482850161170e565b602083015250604061186f848285016115a0565b6040830152506060611883848285016115a0565b6060830152506080611897848285016115a0565b60808301525092915050565b600061018082840312156118ba576118b9611657565b5b6118c56101006116cd565b905060006118d5848285016115a0565b60008301525060206118e9848285016115a0565b60208301525060406118fd848285016115a0565b6040830152506060611911848285016115a0565b606083015250608061192584828501611817565b60808301525061012061193a8482850161170e565b60a08301525061014061194f8482850161170e565b60c083015250610160611964848285016115a0565b60e08301525092915050565b600080fd5b600067ffffffffffffffff8211156119905761198f61166d565b5b602082029050602081019050919050565b600080fd5b60006119b96119b484611975565b6116cd565b905080838252602082019050602084028301858111156119dc576119db6119a1565b5b835b81811015611a0557806119f188826115a0565b8452602084019350506020810190506119de565b5050509392505050565b600082601f830112611a2457611a23611970565b5b8135611a348482602086016119a6565b91505092915050565b600060608284031215611a5357611a52611657565b5b611a5d60606116cd565b90506000611a6d8482850161170e565b6000830152506020611a818482850161170e565b6020830152506040611a958482850161170e565b60408301525092915050565b60006101608284031215611ab857611ab7611657565b5b611ac36101206116cd565b90506000611ad3848285016115a0565b600083015250602082013567ffffffffffffffff811115611af757611af66116e8565b5b611b0384828501611a0f565b6020830152506040611b17848285016115a0565b6040830152506060611b2b848285016115a0565b6060830152506080611b3f84828501611a3d565b60808301525060e0611b53848285016115a0565b60a083015250610100611b68848285016115a0565b60c083015250610120611b7d848285016115a0565b60e083015250610140611b92848285016115a0565b6101008301525092915050565b60008060006101c08486031215611bb957611bb8611575565b5b6000611bc7868287016115a0565b9350506020611bd8868287016118a3565b9250506101a084013567ffffffffffffffff811115611bfa57611bf961157a565b5b611c0686828701611aa1565b9150509250925092565b611c198161157f565b82525050565b611c28816116ed565b82525050565b60c082016000820151611c446000850182611c10565b506020820151611c576020850182611c10565b506040820151611c6a6040850182611c1f565b506060820151611c7d6060850182611c1f565b506080820151611c906080850182611c10565b5060a0820151611ca360a0850182611c10565b50505050565b600060c082019050611cbe6000830184611c2e565b92915050565b6000611ccf8261151d565b9050919050565b611cdf81611cc4565b82525050565b6000602082019050611cfa6000830184611cd6565b92915050565b60006101208284031215611d1757611d16611657565b5b611d226101206116cd565b90506000611d32848285016115a0565b6000830152506020611d46848285016115a0565b6020830152506040611d5a848285016115a0565b6040830152506060611d6e848285016115a0565b6060830152506080611d82848285016115a0565b60808301525060a0611d96848285016115a0565b60a08301525060c0611daa848285016115a0565b60c08301525060e0611dbe848285016115a0565b60e083015250610100611dd3848285016115a0565b6101008301525092915050565b6000806000806102e08587031215611dfb57611dfa611575565b5b6000611e0987828801611d00565b945050610120611e1b878288016118a3565b9350506102a085013567ffffffffffffffff811115611e3d57611e3c61157a565b5b611e4987828801611aa1565b9250506102c0611e5b878288016115a0565b91505092959194509250565b60e082016000820151611e7d6000850182611c10565b506020820151611e906020850182611c1f565b506040820151611ea36040850182611c1f565b506060820151611eb66060850182611c1f565b506080820151611ec96080850182611c10565b5060a0820151611edc60a0850182611c10565b5060c0820151611eef60c0850182611c10565b50505050565b600060e082019050611f0a6000830184611e67565b92915050565b60008060408385031215611f2757611f26611575565b5b6000611f35858286016115a0565b9250506020611f46858286016115a0565b9150509250929050565b6000611f5b8261151d565b9050919050565b611f6b81611f50565b82525050565b6000602082019050611f866000830184611f62565b92915050565b60038110611f9957600080fd5b50565b600081359050611fab81611f8c565b92915050565b60008115159050919050565b611fc681611fb1565b8114611fd157600080fd5b50565b600081359050611fe381611fbd565b92915050565b60008060008060008060c0878903121561200657612005611575565b5b600061201489828a016115a0565b965050602061202589828a01611f9c565b955050604061203689828a01611642565b945050606061204789828a016115a0565b935050608061205889828a01611fd4565b92505060a061206989828a01611fd4565b9150509295509295509295565b600080600080600060a0868803121561209257612091611575565b5b60006120a0888289016115a0565b95505060206120b188828901611fd4565b94505060406120c288828901611f9c565b93505060606120d388828901611642565b92505060806120e488828901611fd4565b9150509295509295909350565b6120fa81611fb1565b82525050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b600381106121405761213f612100565b5b50565b60008190506121518261212f565b919050565b600061216182612143565b9050919050565b61217181612156565b82525050565b6005811061218857612187612100565b5b50565b600081905061219982612177565b919050565b60006121a98261218b565b9050919050565b6121b98161219e565b82525050565b60e0820160008201516121d56000850182611c10565b5060208201516121e86020850182611c10565b5060408201516121fb6040850182611c10565b50606082015161220e6060850182611c10565b5060808201516122216080850182611c10565b5060a082015161223460a0850182611c10565b5060c082015161224760c0850182611c10565b50505050565b6101e08201600082015161226460008501826120f1565b50602082015161227760208501826120f1565b50604082015161228a6040850182612168565b50606082015161229d60608501826121b0565b5060808201516122b06080850182611c10565b5060a08201516122c360a0850182611c10565b5060c08201516122d660c0850182611c10565b5060e08201516122e960e0850182611c10565b506101008201516122fe6101008501826121bf565b50505050565b60006101e08201905061231a600083018461224d565b92915050565b600061232b8261151d565b9050919050565b61233b81612320565b82525050565b60006020820190506123566000830184612332565b92915050565b60008060006060848603121561237557612374611575565b5b600061238386828701611f9c565b935050602061239486828701611642565b92505060406123a586828701611fd4565b9150509250925092565b60006123ba8261151d565b9050919050565b6123ca816123af565b82525050565b60006020820190506123e560008301846123c1565b92915050565b6000815190506123fa81611589565b92915050565b6000610120828403121561241757612416611657565b5b6124226101206116cd565b90506000612432848285016123eb565b6000830152506020612446848285016123eb565b602083015250604061245a848285016123eb565b604083015250606061246e848285016123eb565b6060830152506080612482848285016123eb565b60808301525060a0612496848285016123eb565b60a08301525060c06124aa848285016123eb565b60c08301525060e06124be848285016123eb565b60e0830152506101006124d3848285016123eb565b6101008301525092915050565b600061012082840312156124f7576124f6611575565b5b600061250584828501612400565b91505092915050565b60006080820190506125236000830187611608565b6125306020830186611608565b61253d6040830185611608565b61254a6060830184611608565b95945050505050565b60006020828403121561256957612568611575565b5b6000612577848285016123eb565b91505092915050565b600061258b826114d1565b9050919050565b61259b81612580565b82525050565b60006020820190506125b66000830184612592565b92915050565b6000815190506125cb816116f7565b92915050565b6000602082840312156125e7576125e6611575565b5b60006125f5848285016125bc565b91505092915050565b6126078161157f565b82525050565b612616816116ed565b82525050565b60a08201600082015161263260008501826125fe565b50602082015161264560208501826125fe565b50604082015161265860408501826125fe565b50606082015161266b60608501826125fe565b50608082015161267e608085018261260d565b50505050565b600060a082019050612699600083018461261c565b92915050565b600060c082840312156126b5576126b4611657565b5b6126bf60c06116cd565b905060006126cf848285016123eb565b60008301525060206126e3848285016123eb565b60208301525060406126f7848285016125bc565b604083015250606061270b848285016125bc565b606083015250608061271f848285016123eb565b60808301525060a0612733848285016123eb565b60a08301525092915050565b600060c0828403121561275557612754611575565b5b60006127638482850161269f565b91505092915050565b60006060828403121561278257612781611657565b5b61278c60606116cd565b9050600061279c848285016125bc565b60008301525060206127b0848285016125bc565b60208301525060406127c4848285016125bc565b60408301525092915050565b600061010082840312156127e7576127e6611657565b5b6127f160c06116cd565b90506000612801848285016123eb565b6000830152506020612815848285016123eb565b6020830152506040612829848285016123eb565b604083015250606061283d848285016123eb565b6060830152506080612851848285016123eb565b60808301525060a06128658482850161276c565b60a08301525092915050565b6000610100828403121561288857612887611575565b5b6000612896848285016127d0565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60006128d98261157f565b91506128e48361157f565b92508282019050808211156128fc576128fb61289f565b5b92915050565b600061290d826116ed565b9150612918836116ed565b925082820390508181126000841216828213600085121516171561293f5761293e61289f565b5b92915050565b6000612950826116ed565b915061295b836116ed565b9250828201905082811215600083121683821260008412151617156129835761298261289f565b5b92915050565b6000612994826116ed565b91507f800000000000000000000000000000000000000000000000000000000000000082036129c6576129c561289f565b5b816000039050919050565b600061012082840312156129e8576129e7611657565b5b6129f36101206116cd565b90506000612a03848285016123eb565b6000830152506020612a17848285016123eb565b6020830152506040612a2b848285016123eb565b6040830152506060612a3f848285016123eb565b6060830152506080612a53848285016123eb565b60808301525060a0612a67848285016123eb565b60a08301525060c0612a7b848285016123eb565b60c08301525060e0612a8f848285016123eb565b60e083015250610100612aa4848285016123eb565b6101008301525092915050565b600081519050612ac081611fbd565b92915050565b6000612ad9612ad484611975565b6116cd565b90508083825260208201905060208402830185811115612afc57612afb6119a1565b5b835b81811015612b255780612b1188826123eb565b845260208401935050602081019050612afe565b5050509392505050565b600082601f830112612b4457612b43611970565b5b8151612b54848260208601612ac6565b91505092915050565b600060a08284031215612b7357612b72611657565b5b612b7d60a06116cd565b90506000612b8d848285016123eb565b6000830152506020612ba1848285016123eb565b6020830152506040612bb5848285016123eb565b6040830152506060612bc984828501612ab1565b606083015250608082015167ffffffffffffffff811115612bed57612bec6116e8565b5b612bf984828501612b2f565b60808301525092915050565b6000806101408385031215612c1d57612c1c611575565b5b6000612c2b858286016129d1565b92505061012083015167ffffffffffffffff811115612c4d57612c4c61157a565b5b612c5985828601612b5d565b9150509250929050565b600060a08284031215612c7957612c78611657565b5b612c8360a06116cd565b90506000612c93848285016125bc565b6000830152506020612ca7848285016125bc565b6020830152506040612cbb848285016123eb565b6040830152506060612ccf848285016123eb565b6060830152506080612ce3848285016123eb565b60808301525092915050565b60006101808284031215612d0657612d05611657565b5b612d116101006116cd565b90506000612d21848285016123eb565b6000830152506020612d35848285016123eb565b6020830152506040612d49848285016123eb565b6040830152506060612d5d848285016123eb565b6060830152506080612d7184828501612c63565b608083015250610120612d86848285016125bc565b60a083015250610140612d9b848285016125bc565b60c083015250610160612db0848285016123eb565b60e08301525092915050565b60006101808284031215612dd357612dd2611575565b5b6000612de184828501612cef565b91505092915050565b60006101608284031215612e0157612e00611657565b5b612e0c6101206116cd565b90506000612e1c848285016123eb565b600083015250602082015167ffffffffffffffff811115612e4057612e3f6116e8565b5b612e4c84828501612b2f565b6020830152506040612e60848285016123eb565b6040830152506060612e74848285016123eb565b6060830152506080612e888482850161276c565b60808301525060e0612e9c848285016123eb565b60a083015250610100612eb1848285016123eb565b60c083015250610120612ec6848285016123eb565b60e083015250610140612edb848285016123eb565b6101008301525092915050565b600060208284031215612efe57612efd611575565b5b600082015167ffffffffffffffff811115612f1c57612f1b61157a565b5b612f2884828501612dea565b91505092915050565b600061022082019050612f47600083018661224d565b612f556101e0830185611608565b612f63610200830184611608565b949350505050565b60008060408385031215612f8257612f81611575565b5b6000612f90858286016123eb565b9250506020612fa1858286016123eb565b9150509250929050565b60006102c082019050612fc1600083018561224d565b612fcf6101e0830184611e67565b9392505050565b600060c08284031215612fec57612feb611657565b5b612ff660c06116cd565b90506000613006848285016125bc565b600083015250602061301a848285016125bc565b602083015250604061302e848285016123eb565b6040830152506060613042848285016123eb565b6060830152506080613056848285016123eb565b60808301525060a061306a848285016123eb565b60a08301525092915050565b600060c0828403121561308c5761308b611575565b5b600061309a84828501612fd6565b91505092915050565b60006102e0820190506130b9600083018661224d565b6130c76101e0830185611e67565b6130d56102c0830184611608565b949350505050565b600061010082840312156130f4576130f3611657565b5b6130ff6101006116cd565b9050600061310f848285016123eb565b6000830152506020613123848285016123eb565b6020830152506040613137848285016123eb565b604083015250606061314b848285016123eb565b606083015250608061315f848285016123eb565b60808301525060a0613173848285016123eb565b60a08301525060c0613187848285016123eb565b60c08301525060e061319b848285016123eb565b60e08301525092915050565b600061010082840312156131be576131bd611575565b5b60006131cc848285016130dd565b91505092915050565b60006131e08261157f565b91506131eb8361157f565b92508282039050818111156132035761320261289f565b5b92915050565b600060e0828403121561321f5761321e611657565b5b61322960e06116cd565b90506000613239848285016123eb565b600083015250602061324d848285016123eb565b6020830152506040613261848285016123eb565b6040830152506060613275848285016123eb565b6060830152506080613289848285016123eb565b60808301525060a061329d848285016123eb565b60a08301525060c06132b1848285016123eb565b60c08301525092915050565b600060e082840312156132d3576132d2611575565b5b60006132e184828501613209565b91505092915050565b600581106132fb576132fa612100565b5b50565b600081905061330c826132ea565b919050565b600061331c826132fe565b9050919050565b61332c81613311565b82525050565b60006040820190506133476000830185612592565b6133546020830184613323565b9392505050565b60008160011c9050919050565b6000808291508390505b60018511156133b25780860481111561338e5761338d61289f565b5b600185161561339d5780820291505b80810290506133ab8561335b565b9450613372565b94509492505050565b6000826133cb5760019050613487565b816133d95760009050613487565b81600181146133ef57600281146133f957613428565b6001915050613487565b60ff84111561340b5761340a61289f565b5b8360020a9150848211156134225761342161289f565b5b50613487565b5060208310610133831016604e8410600b841016171561345d5782820a9050838111156134585761345761289f565b5b613487565b61346a8484846001613368565b925090508184048111156134815761348061289f565b5b81810290505b9392505050565b60006134998261157f565b91506134a48361157f565b92506134d17fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84846133bb565b905092915050565b60006134e48261157f565b91506134ef8361157f565b9250817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff04831182151516156135285761352761289f565b5b828202905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600061356d8261157f565b91506135788361157f565b92508261358857613587613533565b5b828204905092915050565b600082825260208201905092915050565b7f53616665436173743a2076616c756520646f65736e27742066697420696e206160008201527f6e20696e74323536000000000000000000000000000000000000000000000000602082015250565b6000613600602883613593565b915061360b826135a4565b604082019050919050565b6000602082019050818103600083015261362f816135f3565b9050919050565b6000613641826116ed565b915061364c836116ed565b9250827f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff048211600084136000841316161561368b5761368a61289f565b5b817f800000000000000000000000000000000000000000000000000000000000000005831260008412600084131616156136c8576136c761289f565b5b827f800000000000000000000000000000000000000000000000000000000000000005821260008413600084121616156137055761370461289f565b5b827f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff05821260008412600084121616156137425761374161289f565b5b828202905092915050565b6000613758826116ed565b9150613763836116ed565b92508261377357613772613533565b5b600160000383147f8000000000000000000000000000000000000000000000000000000000000000831416156137ac576137ab61289f565b5b82820590509291505056fea2646970667358221220055beeec0b3c6eb4be0267a6a078b71cb8265c80f75332a171ab4af5bc308b8664736f6c63430008100033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100cf5760003560e01c8063a2d804ee1161008c578063b65f4b2a11610066578063b65f4b2a1461024e578063bb4a9f881461027e578063ddfaeb771461029c578063f918b32b146102cc576100cf565b8063a2d804ee146101d0578063a5a249d014610200578063a827e8861461021e576100cf565b8063183a3dfa146100d457806333994cd7146100f257806357193101146101225780635bc8ccc214610152578063665a11ca146101825780638557d638146101a0575b600080fd5b6100dc6102ea565b6040516100e99190611550565b60405180910390f35b61010c600480360381019061010791906115b5565b610310565b6040516101199190611617565b60405180910390f35b61013c600480360381019061013791906117c3565b610489565b6040516101499190611617565b60405180910390f35b61016c60048036038101906101679190611b9f565b610518565b6040516101799190611ca9565b60405180910390f35b61018a6106ae565b6040516101979190611ce5565b60405180910390f35b6101ba60048036038101906101b59190611de0565b6106d4565b6040516101c79190611ef5565b60405180910390f35b6101ea60048036038101906101e59190611f10565b6108ab565b6040516101f79190611617565b60405180910390f35b610208610a11565b6040516102159190611f71565b60405180910390f35b61023860048036038101906102339190611fe9565b610a37565b6040516102459190611617565b60405180910390f35b61026860048036038101906102639190612076565b610f16565b6040516102759190612304565b60405180910390f35b610286611068565b6040516102939190612341565b60405180910390f35b6102b660048036038101906102b1919061235c565b61108c565b6040516102c39190611617565b60405180910390f35b6102d4611277565b6040516102e191906123d0565b60405180910390f35b600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600080600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16636f2fddc66040518163ffffffff1660e01b815260040161012060405180830381865afa158015610381573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103a591906124e0565b90506000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d44558d28584608001518560a0015186606001516040518563ffffffff1660e01b8152600401610416949392919061250e565b602060405180830381865afa158015610433573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104579190612553565b905061047e85610470888461129d90919063ffffffff16565b61129d90919063ffffffff16565b925050509392505050565b600080600160048111156104a05761049f612100565b5b8560048111156104b3576104b2612100565b5b141580156104e557506004808111156104cf576104ce612100565b5b8560048111156104e2576104e1612100565b5b14155b6104f35782602001516104f9565b82600001515b905061050e848261129d90919063ffffffff16565b9150509392505050565b6105206113a7565b6040518060a0016040528061053884604001516112ce565b81526020016105588560600151856060015161129d90919063ffffffff16565b815260200185815260200184604001518152602001600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16634a51c00960008054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040518263ffffffff1660e01b81526004016105e891906125a1565b602060405180830381865afa158015610605573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061062991906125d1565b81525073__$eb86d565a3113b3c398b1080d0d395c3b4$__63036d587890916040518263ffffffff1660e01b81526004016106649190612684565b60c060405180830381865af4158015610681573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106a5919061273f565b90509392505050565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6106dc6113dd565b6000600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16636461a97b6040518163ffffffff1660e01b815260040161010060405180830381865afa15801561074c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107709190612871565b905060006107908760a00151886080015161078b91906128ce565b6112e1565b61079d88606001516112e1565b6107a79190612902565b905060006107b88860e001516112e1565b6107c58960c001516112e1565b6107cf9190612902565b9050600061081f6107e78960800151604001516112e1565b8960c001518a60a0015185876107fd9190612945565b6108079190612902565b6108119190612902565b61134e90919063ffffffff16565b90508360a001516020015161083390612989565b856020018181525050808460a001516020015161084f90612989565b6108599190612945565b85604001818152505061087d8860600151886060015161129d90919063ffffffff16565b856080018181525050858560c00181815250508661010001518560a001818152505050505050949350505050565b600080600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16636f2fddc66040518163ffffffff1660e01b815260040161012060405180830381865afa15801561091c573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061094091906124e0565b90506000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d44558d2858460200151856040015186600001516040518563ffffffff1660e01b81526004016109b1949392919061250e565b602060405180830381865afa1580156109ce573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109f29190612553565b9050610a07858261129d90919063ffffffff16565b9250505092915050565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600080610a478585898987610f16565b905060008060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663c4c4a0d08b6040518263ffffffff1660e01b8152600401610aa59190611617565b600060405180830381865afa158015610ac2573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f82011682018060405250810190610aeb9190612c05565b915091506000600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663641c37368c6040518263ffffffff1660e01b8152600401610b4c9190611617565b61018060405180830381865afa158015610b6a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b8e9190612dbc565b90506000600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16637fdf17e283602001516040518263ffffffff1660e01b8152600401610bf19190611617565b600060405180830381865afa158015610c0e573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f82011682018060405250810190610c379190612ee8565b90506000610c4a8660e001518484610518565b90506000610c5e86858585608001516106d4565b90506000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166331adee8e8986606001518a604001516040518463ffffffff1660e01b8152600401610cc993929190612f31565b6040805180830381865afa158015610ce5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d099190612f6b565b9150506000610d198e8e86610489565b90506000610d2b8289602001516108ab565b90506000610d468b60e001518c608001518b60200151610310565b90506000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16638e8fd8b98d886040518363ffffffff1660e01b8152600401610da7929190612fab565b60c060405180830381865afa158015610dc4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610de89190613076565b90506000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663140c12578e89896040518463ffffffff1660e01b8152600401610e4b939291906130a3565b61010060405180830381865afa158015610e69573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e8d91906131a7565b905060008160e001518360a001518587610ea791906128ce565b610eb191906128ce565b610ebb91906128ce565b90508d6000015115610eda578086610ed391906128ce565b9e50610efe565b85811115610eee5785905060009e50610efd565b8086610efa91906131d5565b9e505b5b50505050505050505050505050509695505050505050565b610f1e61141a565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16630910a5106040518163ffffffff1660e01b815260040160e060405180830381865afa158015610f8b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610faf91906132bd565b60a0015181610100015160a0018181525050858160800181815250508181602001901515908115158152505084816000019015159081151581525050610ff684848461108c565b8160e0018181525050828160600190600481111561101757611016612100565b5b9081600481111561102b5761102a612100565b5b81525050838160400190600281111561104757611046612100565b5b9081600281111561105b5761105a612100565b5b8152505095945050505050565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000806002808111156110a2576110a1612100565b5b8560028111156110b5576110b4612100565b5b036110c357600290506111af565b600060048111156110d7576110d6612100565b5b8460048111156110ea576110e9612100565b5b1480611119575060048081111561110457611103612100565b5b84600481111561111757611116612100565b5b145b15611168576000600281111561113257611131612100565b5b85600281111561114557611144612100565b5b1461115e5782611156576000611159565b60035b611161565b60015b90506111ae565b6000600281111561117c5761117b612100565b5b85600281111561118f5761118e612100565b5b146111a857826111a05760016111a3565b60045b6111ab565b60005b90505b5b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166373cbfc6960008054906101000a900473ffffffffffffffffffffffffffffffffffffffff16836040518363ffffffff1660e01b815260040161122c929190613332565b602060405180830381865afa158015611249573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061126d9190612553565b9150509392505050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000601260ff16600a6112b0919061348e565b82846112bc91906134d9565b6112c69190613562565b905092915050565b60006112da428361137f565b9050919050565b60007f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821115611346576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161133d90613616565b60405180910390fd5b819050919050565b6000601260ff16600a611361919061348e565b828461136d9190613636565b611377919061374d565b905092915050565b60008282111561139c57828261139591906131d5565b90506113a1565b600090505b92915050565b6040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6040518060e00160405280600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6040518061012001604052806000151581526020016000151581526020016000600281111561144c5761144b612100565b5b81526020016000600481111561146557611464612100565b5b81526020016000815260200160008152602001600081526020016000815260200161148e611494565b81525090565b6040518060e00160405280600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b600061151661151161150c846114d1565b6114f1565b6114d1565b9050919050565b6000611528826114fb565b9050919050565b600061153a8261151d565b9050919050565b61154a8161152f565b82525050565b60006020820190506115656000830184611541565b92915050565b6000604051905090565b600080fd5b600080fd5b6000819050919050565b6115928161157f565b811461159d57600080fd5b50565b6000813590506115af81611589565b92915050565b6000806000606084860312156115ce576115cd611575565b5b60006115dc868287016115a0565b93505060206115ed868287016115a0565b92505060406115fe868287016115a0565b9150509250925092565b6116118161157f565b82525050565b600060208201905061162c6000830184611608565b92915050565b6005811061163f57600080fd5b50565b60008135905061165181611632565b92915050565b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6116a58261165c565b810181811067ffffffffffffffff821117156116c4576116c361166d565b5b80604052505050565b60006116d761156b565b90506116e3828261169c565b919050565b600080fd5b6000819050919050565b611700816116ed565b811461170b57600080fd5b50565b60008135905061171d816116f7565b92915050565b600060c0828403121561173957611738611657565b5b61174360c06116cd565b90506000611753848285016115a0565b6000830152506020611767848285016115a0565b602083015250604061177b8482850161170e565b604083015250606061178f8482850161170e565b60608301525060806117a3848285016115a0565b60808301525060a06117b7848285016115a0565b60a08301525092915050565b600080600061010084860312156117dd576117dc611575565b5b60006117eb86828701611642565b93505060206117fc868287016115a0565b925050604061180d86828701611723565b9150509250925092565b600060a0828403121561182d5761182c611657565b5b61183760a06116cd565b905060006118478482850161170e565b600083015250602061185b8482850161170e565b602083015250604061186f848285016115a0565b6040830152506060611883848285016115a0565b6060830152506080611897848285016115a0565b60808301525092915050565b600061018082840312156118ba576118b9611657565b5b6118c56101006116cd565b905060006118d5848285016115a0565b60008301525060206118e9848285016115a0565b60208301525060406118fd848285016115a0565b6040830152506060611911848285016115a0565b606083015250608061192584828501611817565b60808301525061012061193a8482850161170e565b60a08301525061014061194f8482850161170e565b60c083015250610160611964848285016115a0565b60e08301525092915050565b600080fd5b600067ffffffffffffffff8211156119905761198f61166d565b5b602082029050602081019050919050565b600080fd5b60006119b96119b484611975565b6116cd565b905080838252602082019050602084028301858111156119dc576119db6119a1565b5b835b81811015611a0557806119f188826115a0565b8452602084019350506020810190506119de565b5050509392505050565b600082601f830112611a2457611a23611970565b5b8135611a348482602086016119a6565b91505092915050565b600060608284031215611a5357611a52611657565b5b611a5d60606116cd565b90506000611a6d8482850161170e565b6000830152506020611a818482850161170e565b6020830152506040611a958482850161170e565b60408301525092915050565b60006101608284031215611ab857611ab7611657565b5b611ac36101206116cd565b90506000611ad3848285016115a0565b600083015250602082013567ffffffffffffffff811115611af757611af66116e8565b5b611b0384828501611a0f565b6020830152506040611b17848285016115a0565b6040830152506060611b2b848285016115a0565b6060830152506080611b3f84828501611a3d565b60808301525060e0611b53848285016115a0565b60a083015250610100611b68848285016115a0565b60c083015250610120611b7d848285016115a0565b60e083015250610140611b92848285016115a0565b6101008301525092915050565b60008060006101c08486031215611bb957611bb8611575565b5b6000611bc7868287016115a0565b9350506020611bd8868287016118a3565b9250506101a084013567ffffffffffffffff811115611bfa57611bf961157a565b5b611c0686828701611aa1565b9150509250925092565b611c198161157f565b82525050565b611c28816116ed565b82525050565b60c082016000820151611c446000850182611c10565b506020820151611c576020850182611c10565b506040820151611c6a6040850182611c1f565b506060820151611c7d6060850182611c1f565b506080820151611c906080850182611c10565b5060a0820151611ca360a0850182611c10565b50505050565b600060c082019050611cbe6000830184611c2e565b92915050565b6000611ccf8261151d565b9050919050565b611cdf81611cc4565b82525050565b6000602082019050611cfa6000830184611cd6565b92915050565b60006101208284031215611d1757611d16611657565b5b611d226101206116cd565b90506000611d32848285016115a0565b6000830152506020611d46848285016115a0565b6020830152506040611d5a848285016115a0565b6040830152506060611d6e848285016115a0565b6060830152506080611d82848285016115a0565b60808301525060a0611d96848285016115a0565b60a08301525060c0611daa848285016115a0565b60c08301525060e0611dbe848285016115a0565b60e083015250610100611dd3848285016115a0565b6101008301525092915050565b6000806000806102e08587031215611dfb57611dfa611575565b5b6000611e0987828801611d00565b945050610120611e1b878288016118a3565b9350506102a085013567ffffffffffffffff811115611e3d57611e3c61157a565b5b611e4987828801611aa1565b9250506102c0611e5b878288016115a0565b91505092959194509250565b60e082016000820151611e7d6000850182611c10565b506020820151611e906020850182611c1f565b506040820151611ea36040850182611c1f565b506060820151611eb66060850182611c1f565b506080820151611ec96080850182611c10565b5060a0820151611edc60a0850182611c10565b5060c0820151611eef60c0850182611c10565b50505050565b600060e082019050611f0a6000830184611e67565b92915050565b60008060408385031215611f2757611f26611575565b5b6000611f35858286016115a0565b9250506020611f46858286016115a0565b9150509250929050565b6000611f5b8261151d565b9050919050565b611f6b81611f50565b82525050565b6000602082019050611f866000830184611f62565b92915050565b60038110611f9957600080fd5b50565b600081359050611fab81611f8c565b92915050565b60008115159050919050565b611fc681611fb1565b8114611fd157600080fd5b50565b600081359050611fe381611fbd565b92915050565b60008060008060008060c0878903121561200657612005611575565b5b600061201489828a016115a0565b965050602061202589828a01611f9c565b955050604061203689828a01611642565b945050606061204789828a016115a0565b935050608061205889828a01611fd4565b92505060a061206989828a01611fd4565b9150509295509295509295565b600080600080600060a0868803121561209257612091611575565b5b60006120a0888289016115a0565b95505060206120b188828901611fd4565b94505060406120c288828901611f9c565b93505060606120d388828901611642565b92505060806120e488828901611fd4565b9150509295509295909350565b6120fa81611fb1565b82525050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b600381106121405761213f612100565b5b50565b60008190506121518261212f565b919050565b600061216182612143565b9050919050565b61217181612156565b82525050565b6005811061218857612187612100565b5b50565b600081905061219982612177565b919050565b60006121a98261218b565b9050919050565b6121b98161219e565b82525050565b60e0820160008201516121d56000850182611c10565b5060208201516121e86020850182611c10565b5060408201516121fb6040850182611c10565b50606082015161220e6060850182611c10565b5060808201516122216080850182611c10565b5060a082015161223460a0850182611c10565b5060c082015161224760c0850182611c10565b50505050565b6101e08201600082015161226460008501826120f1565b50602082015161227760208501826120f1565b50604082015161228a6040850182612168565b50606082015161229d60608501826121b0565b5060808201516122b06080850182611c10565b5060a08201516122c360a0850182611c10565b5060c08201516122d660c0850182611c10565b5060e08201516122e960e0850182611c10565b506101008201516122fe6101008501826121bf565b50505050565b60006101e08201905061231a600083018461224d565b92915050565b600061232b8261151d565b9050919050565b61233b81612320565b82525050565b60006020820190506123566000830184612332565b92915050565b60008060006060848603121561237557612374611575565b5b600061238386828701611f9c565b935050602061239486828701611642565b92505060406123a586828701611fd4565b9150509250925092565b60006123ba8261151d565b9050919050565b6123ca816123af565b82525050565b60006020820190506123e560008301846123c1565b92915050565b6000815190506123fa81611589565b92915050565b6000610120828403121561241757612416611657565b5b6124226101206116cd565b90506000612432848285016123eb565b6000830152506020612446848285016123eb565b602083015250604061245a848285016123eb565b604083015250606061246e848285016123eb565b6060830152506080612482848285016123eb565b60808301525060a0612496848285016123eb565b60a08301525060c06124aa848285016123eb565b60c08301525060e06124be848285016123eb565b60e0830152506101006124d3848285016123eb565b6101008301525092915050565b600061012082840312156124f7576124f6611575565b5b600061250584828501612400565b91505092915050565b60006080820190506125236000830187611608565b6125306020830186611608565b61253d6040830185611608565b61254a6060830184611608565b95945050505050565b60006020828403121561256957612568611575565b5b6000612577848285016123eb565b91505092915050565b600061258b826114d1565b9050919050565b61259b81612580565b82525050565b60006020820190506125b66000830184612592565b92915050565b6000815190506125cb816116f7565b92915050565b6000602082840312156125e7576125e6611575565b5b60006125f5848285016125bc565b91505092915050565b6126078161157f565b82525050565b612616816116ed565b82525050565b60a08201600082015161263260008501826125fe565b50602082015161264560208501826125fe565b50604082015161265860408501826125fe565b50606082015161266b60608501826125fe565b50608082015161267e608085018261260d565b50505050565b600060a082019050612699600083018461261c565b92915050565b600060c082840312156126b5576126b4611657565b5b6126bf60c06116cd565b905060006126cf848285016123eb565b60008301525060206126e3848285016123eb565b60208301525060406126f7848285016125bc565b604083015250606061270b848285016125bc565b606083015250608061271f848285016123eb565b60808301525060a0612733848285016123eb565b60a08301525092915050565b600060c0828403121561275557612754611575565b5b60006127638482850161269f565b91505092915050565b60006060828403121561278257612781611657565b5b61278c60606116cd565b9050600061279c848285016125bc565b60008301525060206127b0848285016125bc565b60208301525060406127c4848285016125bc565b60408301525092915050565b600061010082840312156127e7576127e6611657565b5b6127f160c06116cd565b90506000612801848285016123eb565b6000830152506020612815848285016123eb565b6020830152506040612829848285016123eb565b604083015250606061283d848285016123eb565b6060830152506080612851848285016123eb565b60808301525060a06128658482850161276c565b60a08301525092915050565b6000610100828403121561288857612887611575565b5b6000612896848285016127d0565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60006128d98261157f565b91506128e48361157f565b92508282019050808211156128fc576128fb61289f565b5b92915050565b600061290d826116ed565b9150612918836116ed565b925082820390508181126000841216828213600085121516171561293f5761293e61289f565b5b92915050565b6000612950826116ed565b915061295b836116ed565b9250828201905082811215600083121683821260008412151617156129835761298261289f565b5b92915050565b6000612994826116ed565b91507f800000000000000000000000000000000000000000000000000000000000000082036129c6576129c561289f565b5b816000039050919050565b600061012082840312156129e8576129e7611657565b5b6129f36101206116cd565b90506000612a03848285016123eb565b6000830152506020612a17848285016123eb565b6020830152506040612a2b848285016123eb565b6040830152506060612a3f848285016123eb565b6060830152506080612a53848285016123eb565b60808301525060a0612a67848285016123eb565b60a08301525060c0612a7b848285016123eb565b60c08301525060e0612a8f848285016123eb565b60e083015250610100612aa4848285016123eb565b6101008301525092915050565b600081519050612ac081611fbd565b92915050565b6000612ad9612ad484611975565b6116cd565b90508083825260208201905060208402830185811115612afc57612afb6119a1565b5b835b81811015612b255780612b1188826123eb565b845260208401935050602081019050612afe565b5050509392505050565b600082601f830112612b4457612b43611970565b5b8151612b54848260208601612ac6565b91505092915050565b600060a08284031215612b7357612b72611657565b5b612b7d60a06116cd565b90506000612b8d848285016123eb565b6000830152506020612ba1848285016123eb565b6020830152506040612bb5848285016123eb565b6040830152506060612bc984828501612ab1565b606083015250608082015167ffffffffffffffff811115612bed57612bec6116e8565b5b612bf984828501612b2f565b60808301525092915050565b6000806101408385031215612c1d57612c1c611575565b5b6000612c2b858286016129d1565b92505061012083015167ffffffffffffffff811115612c4d57612c4c61157a565b5b612c5985828601612b5d565b9150509250929050565b600060a08284031215612c7957612c78611657565b5b612c8360a06116cd565b90506000612c93848285016125bc565b6000830152506020612ca7848285016125bc565b6020830152506040612cbb848285016123eb565b6040830152506060612ccf848285016123eb565b6060830152506080612ce3848285016123eb565b60808301525092915050565b60006101808284031215612d0657612d05611657565b5b612d116101006116cd565b90506000612d21848285016123eb565b6000830152506020612d35848285016123eb565b6020830152506040612d49848285016123eb565b6040830152506060612d5d848285016123eb565b6060830152506080612d7184828501612c63565b608083015250610120612d86848285016125bc565b60a083015250610140612d9b848285016125bc565b60c083015250610160612db0848285016123eb565b60e08301525092915050565b60006101808284031215612dd357612dd2611575565b5b6000612de184828501612cef565b91505092915050565b60006101608284031215612e0157612e00611657565b5b612e0c6101206116cd565b90506000612e1c848285016123eb565b600083015250602082015167ffffffffffffffff811115612e4057612e3f6116e8565b5b612e4c84828501612b2f565b6020830152506040612e60848285016123eb565b6040830152506060612e74848285016123eb565b6060830152506080612e888482850161276c565b60808301525060e0612e9c848285016123eb565b60a083015250610100612eb1848285016123eb565b60c083015250610120612ec6848285016123eb565b60e083015250610140612edb848285016123eb565b6101008301525092915050565b600060208284031215612efe57612efd611575565b5b600082015167ffffffffffffffff811115612f1c57612f1b61157a565b5b612f2884828501612dea565b91505092915050565b600061022082019050612f47600083018661224d565b612f556101e0830185611608565b612f63610200830184611608565b949350505050565b60008060408385031215612f8257612f81611575565b5b6000612f90858286016123eb565b9250506020612fa1858286016123eb565b9150509250929050565b60006102c082019050612fc1600083018561224d565b612fcf6101e0830184611e67565b9392505050565b600060c08284031215612fec57612feb611657565b5b612ff660c06116cd565b90506000613006848285016125bc565b600083015250602061301a848285016125bc565b602083015250604061302e848285016123eb565b6040830152506060613042848285016123eb565b6060830152506080613056848285016123eb565b60808301525060a061306a848285016123eb565b60a08301525092915050565b600060c0828403121561308c5761308b611575565b5b600061309a84828501612fd6565b91505092915050565b60006102e0820190506130b9600083018661224d565b6130c76101e0830185611e67565b6130d56102c0830184611608565b949350505050565b600061010082840312156130f4576130f3611657565b5b6130ff6101006116cd565b9050600061310f848285016123eb565b6000830152506020613123848285016123eb565b6020830152506040613137848285016123eb565b604083015250606061314b848285016123eb565b606083015250608061315f848285016123eb565b60808301525060a0613173848285016123eb565b60a08301525060c0613187848285016123eb565b60c08301525060e061319b848285016123eb565b60e08301525092915050565b600061010082840312156131be576131bd611575565b5b60006131cc848285016130dd565b91505092915050565b60006131e08261157f565b91506131eb8361157f565b92508282039050818111156132035761320261289f565b5b92915050565b600060e0828403121561321f5761321e611657565b5b61322960e06116cd565b90506000613239848285016123eb565b600083015250602061324d848285016123eb565b6020830152506040613261848285016123eb565b6040830152506060613275848285016123eb565b6060830152506080613289848285016123eb565b60808301525060a061329d848285016123eb565b60a08301525060c06132b1848285016123eb565b60c08301525092915050565b600060e082840312156132d3576132d2611575565b5b60006132e184828501613209565b91505092915050565b600581106132fb576132fa612100565b5b50565b600081905061330c826132ea565b919050565b600061331c826132fe565b9050919050565b61332c81613311565b82525050565b60006040820190506133476000830185612592565b6133546020830184613323565b9392505050565b60008160011c9050919050565b6000808291508390505b60018511156133b25780860481111561338e5761338d61289f565b5b600185161561339d5780820291505b80810290506133ab8561335b565b9450613372565b94509492505050565b6000826133cb5760019050613487565b816133d95760009050613487565b81600181146133ef57600281146133f957613428565b6001915050613487565b60ff84111561340b5761340a61289f565b5b8360020a9150848211156134225761342161289f565b5b50613487565b5060208310610133831016604e8410600b841016171561345d5782820a9050838111156134585761345761289f565b5b613487565b61346a8484846001613368565b925090508184048111156134815761348061289f565b5b81810290505b9392505050565b60006134998261157f565b91506134a48361157f565b92506134d17fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84846133bb565b905092915050565b60006134e48261157f565b91506134ef8361157f565b9250817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff04831182151516156135285761352761289f565b5b828202905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600061356d8261157f565b91506135788361157f565b92508261358857613587613533565b5b828204905092915050565b600082825260208201905092915050565b7f53616665436173743a2076616c756520646f65736e27742066697420696e206160008201527f6e20696e74323536000000000000000000000000000000000000000000000000602082015250565b6000613600602883613593565b915061360b826135a4565b604082019050919050565b6000602082019050818103600083015261362f816135f3565b9050919050565b6000613641826116ed565b915061364c836116ed565b9250827f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff048211600084136000841316161561368b5761368a61289f565b5b817f800000000000000000000000000000000000000000000000000000000000000005831260008412600084131616156136c8576136c761289f565b5b827f800000000000000000000000000000000000000000000000000000000000000005821260008413600084121616156137055761370461289f565b5b827f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff05821260008412600084121616156137425761374161289f565b5b828202905092915050565b6000613758826116ed565b9150613763836116ed565b92508261377357613772613533565b5b600160000383147f8000000000000000000000000000000000000000000000000000000000000000831416156137ac576137ab61289f565b5b82820590509291505056fea2646970667358221220055beeec0b3c6eb4be0267a6a078b71cb8265c80f75332a171ab4af5bc308b8664736f6c63430008100033",
  "libraries": {
    "BlackScholes": "0xEAC659b8e6458568D84A278d1a1b286DD1e9511B"
  },
  "devdoc": {
    "author": "0nika0",
    "kind": "dev",
    "methods": {
      "calculateOptionPriceFee(uint256,uint256)": {
        "params": {
          "expiry": "The expiration time of the option.",
          "premium": "The premium amount of the option."
        },
        "returns": {
          "fee": "The calculated fee based on the provided premium and expiration time."
        }
      },
      "calculatePremium(uint8,uint256,(uint256,uint256,int256,int256,uint256,uint256))": {
        "params": {
          "amount": "The amount of options being traded.",
          "optionType": "The type of the option: LONG_CALL, LONG_PUT, SHORT_CALL_BASE, SHORT_CALL_QUOTE, SHORT_PUT_QUOTE.",
          "pricesDeltaStdVega": "The struct containing calculated prices, delta, and standard vega."
        },
        "returns": {
          "premium": "The calculated premium for the option trade."
        }
      },
      "calculatePricesDeltaStdVega(uint256,(uint256,uint256,uint256,uint256,(int256,int256,uint256,uint256,uint256),int256,int256,uint256),(uint256,uint256[],uint256,uint256,(int256,int256,int256),uint256,uint256,uint256,uint256))": {
        "details": "This function calculates various option-related values using the Black-Scholes formula.",
        "params": {
          "boardCache": "The cached data for the option board.",
          "spotPrice": "The current spot price of the underlying asset.",
          "strikeCache": "The cached data for the strike associated with the option."
        },
        "returns": {
          "pricesDeltaStdVega": "A struct containing calculated prices, delta, and standard vega."
        }
      },
      "calculateSpotPriceFee(uint256,uint256,uint256)": {
        "params": {
          "amount": "The amount of options being traded.",
          "expiry": "The expiration time of the options.",
          "spotPrice": "The current spot price of the underlying asset."
        },
        "returns": {
          "fee": "The calculated fee based on the provided spot price and trade parameters."
        }
      },
      "calculateTotalCost(uint256,uint8,uint8,uint256,bool,bool)": {
        "details": "This function calculates the approximate value of an option trade based on various parameters.",
        "params": {
          "amount": "The amount of options being traded.",
          "isBuy": "True if it's a buy trade, false if it's a sell trade.",
          "isForceClose": "True if the trade is a force close.",
          "optionType": "The type of the option: LONG_CALL, LONG_PUT, SHORT_CALL_BASE, SHORT_CALL_QUOTE, SHORT_PUT_QUOTE.",
          "strikeId": "The ID of the strike for the option trade.",
          "tradeDirection": "The direction of the trade: OPEN, CLOSE, LIQUIDATE."
        },
        "returns": {
          "totalCost": "The total cost of the trade including fees."
        }
      },
      "getSpotPrice(uint8,uint8,bool)": {
        "params": {
          "isForceClose": "True if the trade is a force close.",
          "optionType": "The type of the option: LONG_CALL, LONG_PUT, SHORT_CALL_BASE, SHORT_CALL_QUOTE, SHORT_PUT_QUOTE.",
          "tradeDirection": "The direction of the trade: OPEN, CLOSE, LIQUIDATE."
        },
        "returns": {
          "spotPrice": "The calculated spot price for the trade."
        }
      },
      "preparetionPricing((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),(uint256,uint256,uint256,uint256,(int256,int256,uint256,uint256,uint256),int256,int256,uint256),(uint256,uint256[],uint256,uint256,(int256,int256,int256),uint256,uint256,uint256,uint256),uint256)": {
        "params": {
          "boardCache": "The cached data for the option board.",
          "strike": "The information about the strike.",
          "strikeCache": "The cached data for the strike.",
          "vega": "The calculated vega value."
        },
        "returns": {
          "pricing": "The populated trade pricing data."
        }
      },
      "preparetionTrade(uint256,bool,uint8,uint8,bool)": {
        "params": {
          "amount": "The amount of options being traded.",
          "isBuy": "True if it's a buy trade, false if it's a sell trade.",
          "isForceClose": "True if the trade is a force close.",
          "optionType": "The type of the option: LONG_CALL, LONG_PUT, SHORT_CALL_BASE, SHORT_CALL_QUOTE, SHORT_PUT_QUOTE.",
          "tradeDirection": "The direction of the trade: OPEN, CLOSE, LIQUIDATE."
        },
        "returns": {
          "trade": "The populated trade parameters."
        }
      }
    },
    "title": "LyraCalc",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "calculateOptionPriceFee(uint256,uint256)": {
        "notice": "Calculates the fee based on the option premium and expiration time, considering time weighting."
      },
      "calculatePremium(uint8,uint256,(uint256,uint256,int256,int256,uint256,uint256))": {
        "notice": "Calculates the premium for the option trade based on the option type and other parameters."
      },
      "calculatePricesDeltaStdVega(uint256,(uint256,uint256,uint256,uint256,(int256,int256,uint256,uint256,uint256),int256,int256,uint256),(uint256,uint256[],uint256,uint256,(int256,int256,int256),uint256,uint256,uint256,uint256))": {
        "notice": "Calculates option prices, delta, and standard vega using the Black-Scholes model."
      },
      "calculateSpotPriceFee(uint256,uint256,uint256)": {
        "notice": "Calculates the fee based on spot price and trade amount, taking into account time weighting."
      },
      "calculateTotalCost(uint256,uint8,uint8,uint256,bool,bool)": {
        "notice": "Calculates the total cost for a given trade."
      },
      "getSpotPrice(uint8,uint8,bool)": {
        "notice": "Retrieves the appropriate spot price based on trade direction, option type, and force close status."
      },
      "preparetionPricing((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),(uint256,uint256,uint256,uint256,(int256,int256,uint256,uint256,uint256),int256,int256,uint256),(uint256,uint256[],uint256,uint256,(int256,int256,int256),uint256,uint256,uint256,uint256),uint256)": {
        "notice": "Prepares trade pricing data based on strike and greek cache information."
      },
      "preparetionTrade(uint256,bool,uint8,uint8,bool)": {
        "notice": "Prepares deal parameters for totalCost calculation."
      }
    },
    "notice": "A smart contract for calculating the total cost of option trades and related fees. This contract leverages the Black-Scholes model and various pricing parameters to estimate trade costs.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 2286,
        "contract": "contracts/LyraCalc.sol:LyraCalc",
        "label": "optionMarket",
        "offset": 0,
        "slot": "0",
        "type": "t_contract(IOptionMarket)3352"
      },
      {
        "astId": 2289,
        "contract": "contracts/LyraCalc.sol:LyraCalc",
        "label": "optionMarketPricer",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(IOptionMarketPricer)3465"
      },
      {
        "astId": 2292,
        "contract": "contracts/LyraCalc.sol:LyraCalc",
        "label": "baseExchangeAdapter",
        "offset": 0,
        "slot": "2",
        "type": "t_contract(IBaseExchangeAdapter)3072"
      },
      {
        "astId": 2295,
        "contract": "contracts/LyraCalc.sol:LyraCalc",
        "label": "optionGreekCache",
        "offset": 0,
        "slot": "3",
        "type": "t_contract(IOptionGreekCache)3207"
      },
      {
        "astId": 2298,
        "contract": "contracts/LyraCalc.sol:LyraCalc",
        "label": "liquidityPool",
        "offset": 0,
        "slot": "4",
        "type": "t_contract(ILiquidityPool)3096"
      }
    ],
    "types": {
      "t_contract(IBaseExchangeAdapter)3072": {
        "encoding": "inplace",
        "label": "contract IBaseExchangeAdapter",
        "numberOfBytes": "20"
      },
      "t_contract(ILiquidityPool)3096": {
        "encoding": "inplace",
        "label": "contract ILiquidityPool",
        "numberOfBytes": "20"
      },
      "t_contract(IOptionGreekCache)3207": {
        "encoding": "inplace",
        "label": "contract IOptionGreekCache",
        "numberOfBytes": "20"
      },
      "t_contract(IOptionMarket)3352": {
        "encoding": "inplace",
        "label": "contract IOptionMarket",
        "numberOfBytes": "20"
      },
      "t_contract(IOptionMarketPricer)3465": {
        "encoding": "inplace",
        "label": "contract IOptionMarketPricer",
        "numberOfBytes": "20"
      }
    }
  }
}