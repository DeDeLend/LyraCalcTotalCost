{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "contracts/interfaces/IBaseExchangeAdapter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.16;\n\ninterface IBaseExchangeAdapter {\n    enum PriceType {\n      MIN_PRICE, // minimise the spot based on logic in adapter - can revert\n      MAX_PRICE, // maximise the spot based on logic in adapter\n      REFERENCE,\n      FORCE_MIN, // minimise the spot based on logic in adapter - shouldn't revert unless feeds are compromised\n      FORCE_MAX\n    }\n\n    function getSpotPriceForMarket(address optionMarket, PriceType pricing) external view returns (uint256 spotPrice); \n    function rateAndCarry(address /*_optionMarket*/) external view returns (int);\n}"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/interfaces/ILiquidityPool.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.16;\n\ninterface ILiquidityPool {\n    struct Liquidity {\n        // Amount of liquidity available for option collateral and premiums\n        uint freeLiquidity;\n        // Amount of liquidity available for withdrawals - different to freeLiquidity\n        uint burnableLiquidity;\n        // Amount of liquidity reserved for long options sold to traders\n        uint reservedCollatLiquidity;\n        // Portion of liquidity reserved for delta hedging (quote outstanding)\n        uint pendingDeltaLiquidity;\n        // Current value of delta hedge\n        uint usedDeltaLiquidity;\n        // Net asset value, including everything and netOptionValue\n        uint NAV;\n        // longs scaled down by this factor in a contract adjustment event\n        uint longScaleFactor;\n    }\n\n    function getLiquidity() external view returns (Liquidity memory);\n}\n"
    },
    "contracts/interfaces/IOptionBuilder.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.16;\n\nimport \"./IOptionMarket.sol\";\n\ninterface IOptionBuilder {\n    enum ProtocolType {\n        lyra_eth,\n        lyra_btc,\n        hegic\n    }\n\n    struct TradeInputParameters {\n        uint strikeId;\n        uint positionId;\n        uint iterations;\n        IOptionMarket.OptionType optionType;\n        uint amount;\n        uint setCollateralTo;\n        uint minTotalCost;\n        uint maxTotalCost;\n        address referrer;\n    }\n\n    function consolidationOfTransactions(ProtocolType[] memory protocolsArrays, bytes[] memory parametersArray, uint256 productType) external;\n    function encodeFromLyra(TradeInputParameters memory params) external pure returns (bytes memory paramData);\n}"
    },
    "contracts/interfaces/IOptionGreekCache.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.16;\n\ninterface IOptionGreekCache {\n    struct StrikeGreeks {\n        int callDelta;\n        int putDelta;\n        uint stdVega;\n        uint callPrice;\n        uint putPrice;\n    }\n\n    struct NetGreeks {\n        int netDelta;\n        int netStdVega;\n        int netOptionValue;\n    }\n\n    struct TradePricing {\n        uint optionPrice;\n        int preTradeAmmNetStdVega;\n        int postTradeAmmNetStdVega;\n        int callDelta;\n        uint volTraded;\n        uint ivVariance;\n        uint vega;\n    }\n\n    struct StrikeCache {\n        uint id;\n        uint boardId;\n        uint strikePrice;\n        uint skew;\n        StrikeGreeks greeks;\n        int callExposure; // long - short\n        int putExposure; // long - short\n        uint skewVariance; // (GWAVSkew - skew)\n    }\n\n    struct OptionBoardCache {\n        uint id;\n        uint[] strikes;\n        uint expiry;\n        uint iv;\n        NetGreeks netGreeks;\n        uint updatedAt;\n        uint updatedAtPrice;\n        uint maxSkewVariance;\n        uint ivVariance;\n    }\n\n    struct GlobalCache {\n        uint minUpdatedAt;\n        uint minUpdatedAtPrice;\n        uint maxUpdatedAtPrice;\n        uint maxSkewVariance;\n        uint maxIvVariance;\n        NetGreeks netGreeks;\n    }\n\n    function getStrikeCache(uint strikeId) external view returns (StrikeCache memory); \n    function getOptionBoardCache(uint boardId) external view returns (OptionBoardCache memory); \n    function getGlobalCache() external view returns (GlobalCache memory);\n}"
    },
    "contracts/interfaces/IOptionMarket.sol": {
      "content": "pragma solidity 0.8.16;\n\nimport \"./ILiquidityPool.sol\";\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ninterface IOptionMarket {\n    enum TradeDirection {\n        OPEN,\n        CLOSE,\n        LIQUIDATE\n    }\n\n    enum OptionType {\n        LONG_CALL,\n        LONG_PUT,\n        SHORT_CALL_BASE,\n        SHORT_CALL_QUOTE,\n        SHORT_PUT_QUOTE\n    }\n\n    struct TradeInputParameters {\n        // id of strike\n        uint strikeId;\n        // OptionToken ERC721 id for position (set to 0 for new positions)\n        uint positionId;\n        // number of sub-orders to break order into (reduces slippage)\n        uint iterations;\n        // type of option to trade\n        OptionType optionType;\n        // number of contracts to trade\n        uint amount;\n        // final amount of collateral to leave in OptionToken position\n        uint setCollateralTo;\n        // revert trade if totalCost is below this value\n        uint minTotalCost;\n        // revert trade if totalCost is above this value\n        uint maxTotalCost;\n        // referrer emitted in Trade event, no on-chain interaction\n        address referrer;\n    }\n\n    struct Strike {\n        // strike listing identifier\n        uint256 id;\n        // strike price\n        uint256 strikePrice;\n        // volatility component specific to the strike listing (boardIv * skew = vol of strike)\n        uint256 skew;\n        // total user long call exposure\n        uint256 longCall;\n        // total user short call (base collateral) exposure\n        uint256 shortCallBase;\n        // total user short call (quote collateral) exposure\n        uint256 shortCallQuote;\n        // total user long put exposure\n        uint256 longPut;\n        // total user short put (quote collateral) exposure\n        uint256 shortPut;\n        // id of board to which strike belongs\n        uint256 boardId;\n    }\n\n    struct OptionBoard {\n        // board identifier\n        uint256 id;\n        // expiry of all strikes belonging to board\n        uint256 expiry;\n        // volatility component specific to board (boardIv * skew = vol of strike)\n        uint256 iv;\n        // admin settable flag blocking all trading on this board\n        bool frozen;\n        // list of all strikes belonging to this board\n        uint256[] strikeIds;\n    }\n\n    struct TradeParameters {\n        bool isBuy;\n        bool isForceClose;\n        TradeDirection tradeDirection;\n        OptionType optionType;\n        uint amount;\n        uint expiry;\n        uint strikePrice;\n        uint spotPrice;\n        ILiquidityPool.Liquidity liquidity;\n    }\n\n    struct Result {\n        uint positionId;\n        uint totalCost;\n        uint totalFee;\n    }\n\n    function getStrike(uint strikeId) external view returns (Strike memory);\n    function getStrikeAndBoard(uint strikeId) external view returns (Strike memory, OptionBoard memory);\n    function openPosition(TradeInputParameters memory params) external returns (Result memory result);\n    function closePosition(TradeInputParameters memory params) external returns (Result memory result);\n    function quoteAsset() external view returns(ERC20);\n    function baseAsset() external view returns(ERC20);\n}"
    },
    "contracts/interfaces/IOptionMarketPricer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.16;\n\nimport \"./IOptionMarket.sol\";\nimport \"./IOptionGreekCache.sol\";\n\ninterface IOptionMarketPricer {\n    struct VegaUtilFeeComponents {\n        int preTradeAmmNetStdVega;\n        int postTradeAmmNetStdVega;\n        uint vegaUtil;\n        uint volTraded;\n        uint NAV;\n        uint vegaUtilFee;\n    }\n\n    struct PricingParameters {\n        // Percentage of option price that is charged as a fee\n        uint optionPriceFeeCoefficient;\n        // Refer to: getTimeWeightedFee()\n        uint optionPriceFee1xPoint;\n        uint optionPriceFee2xPoint;\n        // Percentage of spot price that is charged as a fee per option\n        uint spotPriceFeeCoefficient;\n        // Refer to: getTimeWeightedFee()\n        uint spotPriceFee1xPoint;\n        uint spotPriceFee2xPoint;\n        // Refer to: getVegaUtilFee()\n        uint vegaFeeCoefficient;\n        // The amount of options traded to move baseIv for the board up or down 1 point (depending on trade direction)\n        uint standardSize;\n        // The relative move of skew for a given strike based on standard sizes traded\n        uint skewAdjustmentFactor;\n    }\n\n    struct VarianceFeeComponents {\n        uint varianceFeeCoefficient;\n        uint vega;\n        uint vegaCoefficient;\n        uint skew;\n        uint skewCoefficient;\n        uint ivVariance;\n        uint ivVarianceCoefficient;\n        uint varianceFee;\n    }\n\n    function getVegaUtilFee(\n        IOptionMarket.TradeParameters memory trade,\n        IOptionGreekCache.TradePricing memory pricing\n    ) external view returns (VegaUtilFeeComponents memory vegaUtilFeeComponents);\n\n    function getTimeWeightedFee(\n        uint expiry,\n        uint pointA,\n        uint pointB,\n        uint coefficient\n    ) external view returns (uint timeWeightedFee);\n\n    function getVarianceFee(\n      IOptionMarket.TradeParameters memory trade,\n      IOptionGreekCache.TradePricing memory pricing,\n      uint skew\n    ) external view returns (VarianceFeeComponents memory varianceFeeComponents);\n\n    function pricingParams() external view returns (PricingParameters memory);\n\n    function ivImpactForTrade(\n        IOptionMarket.TradeParameters memory trade,\n        uint boardBaseIv,\n        uint strikeSkew\n    ) external view returns (uint newBaseIv, uint newSkew);\n}"
    },
    "contracts/interfaces/IOptionToken.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.16;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\ninterface IOptionToken is IERC721 {\n    function nextId() external view returns (uint256);\n}"
    },
    "contracts/libraries/BlackScholes.sol": {
      "content": "//SPDX-License-Identifier: ISC\npragma solidity 0.8.16;\n\n// Libraries\nimport \"../synthetix/SignedDecimalMath.sol\";\nimport \"../synthetix/DecimalMath.sol\";\nimport \"./FixedPointMathLib.sol\";\nimport \"./Math.sol\";\n\n/**\n * @title BlackScholes\n * @author Lyra\n * @dev Contract to compute the black scholes price of options. Where the unit is unspecified, it should be treated as a\n * PRECISE_DECIMAL, which has 1e27 units of precision. The default decimal matches the ethereum standard of 1e18 units\n * of precision.\n */\nlibrary BlackScholes {\n  using DecimalMath for uint;\n  using SignedDecimalMath for int;\n\n  struct PricesDeltaStdVega {\n    uint callPrice;\n    uint putPrice;\n    int callDelta;\n    int putDelta;\n    uint vega;\n    uint stdVega;\n  }\n\n  /**\n   * @param timeToExpirySec Number of seconds to the expiry of the option\n   * @param volatilityDecimal Implied volatility over the period til expiry as a percentage\n   * @param spotDecimal The current price of the base asset\n   * @param strikePriceDecimal The strikePrice price of the option\n   * @param rateDecimal The percentage risk free rate + carry cost\n   */\n  struct BlackScholesInputs {\n    uint timeToExpirySec;\n    uint volatilityDecimal;\n    uint spotDecimal;\n    uint strikePriceDecimal;\n    int rateDecimal;\n  }\n\n  uint private constant SECONDS_PER_YEAR = 31536000;\n  /// @dev Internally this library uses 27 decimals of precision\n  uint private constant PRECISE_UNIT = 1e27;\n  uint private constant SQRT_TWOPI = 2506628274631000502415765285;\n  /// @dev Value to use to avoid any division by 0 or values near 0\n  uint private constant MIN_T_ANNUALISED = PRECISE_UNIT / SECONDS_PER_YEAR; // 1 second\n  uint private constant MIN_VOLATILITY = PRECISE_UNIT / 10000; // 0.001%\n  uint private constant VEGA_STANDARDISATION_MIN_DAYS = 7 days;\n  /// @dev Magic numbers for normal CDF\n  uint private constant SPLIT = 7071067811865470000000000000;\n  uint private constant N0 = 220206867912376000000000000000;\n  uint private constant N1 = 221213596169931000000000000000;\n  uint private constant N2 = 112079291497871000000000000000;\n  uint private constant N3 = 33912866078383000000000000000;\n  uint private constant N4 = 6373962203531650000000000000;\n  uint private constant N5 = 700383064443688000000000000;\n  uint private constant N6 = 35262496599891100000000000;\n  uint private constant M0 = 440413735824752000000000000000;\n  uint private constant M1 = 793826512519948000000000000000;\n  uint private constant M2 = 637333633378831000000000000000;\n  uint private constant M3 = 296564248779674000000000000000;\n  uint private constant M4 = 86780732202946100000000000000;\n  uint private constant M5 = 16064177579207000000000000000;\n  uint private constant M6 = 1755667163182640000000000000;\n  uint private constant M7 = 88388347648318400000000000;\n\n  /////////////////////////////////////\n  // Option Pricing public functions //\n  /////////////////////////////////////\n\n  /**\n   * @dev Returns call and put prices for options with given parameters.\n   */\n  function optionPrices(BlackScholesInputs memory bsInput) public pure returns (uint call, uint put) {\n    uint tAnnualised = _annualise(bsInput.timeToExpirySec);\n    uint spotPrecise = bsInput.spotDecimal.decimalToPreciseDecimal();\n    uint strikePricePrecise = bsInput.strikePriceDecimal.decimalToPreciseDecimal();\n    int ratePrecise = bsInput.rateDecimal.decimalToPreciseDecimal();\n    (int d1, int d2) = _d1d2(\n      tAnnualised,\n      bsInput.volatilityDecimal.decimalToPreciseDecimal(),\n      spotPrecise,\n      strikePricePrecise,\n      ratePrecise\n    );\n    (call, put) = _optionPrices(tAnnualised, spotPrecise, strikePricePrecise, ratePrecise, d1, d2);\n    return (call.preciseDecimalToDecimal(), put.preciseDecimalToDecimal());\n  }\n\n  /**\n   * @dev Returns call/put prices and delta/stdVega for options with given parameters.\n   */\n  function pricesDeltaStdVega(BlackScholesInputs memory bsInput) public pure returns (PricesDeltaStdVega memory) {\n    uint tAnnualised = _annualise(bsInput.timeToExpirySec);\n    uint spotPrecise = bsInput.spotDecimal.decimalToPreciseDecimal();\n\n    (int d1, int d2) = _d1d2(\n      tAnnualised,\n      bsInput.volatilityDecimal.decimalToPreciseDecimal(),\n      spotPrecise,\n      bsInput.strikePriceDecimal.decimalToPreciseDecimal(),\n      bsInput.rateDecimal.decimalToPreciseDecimal()\n    );\n    (uint callPrice, uint putPrice) = _optionPrices(\n      tAnnualised,\n      spotPrecise,\n      bsInput.strikePriceDecimal.decimalToPreciseDecimal(),\n      bsInput.rateDecimal.decimalToPreciseDecimal(),\n      d1,\n      d2\n    );\n    (uint vegaPrecise, uint stdVegaPrecise) = _standardVega(d1, spotPrecise, bsInput.timeToExpirySec);\n    (int callDelta, int putDelta) = _delta(d1);\n\n    return\n      PricesDeltaStdVega(\n        callPrice.preciseDecimalToDecimal(),\n        putPrice.preciseDecimalToDecimal(),\n        callDelta.preciseDecimalToDecimal(),\n        putDelta.preciseDecimalToDecimal(),\n        vegaPrecise.preciseDecimalToDecimal(),\n        stdVegaPrecise.preciseDecimalToDecimal()\n      );\n  }\n\n  /**\n   * @dev Returns call delta given parameters.\n   */\n\n  function delta(BlackScholesInputs memory bsInput) public pure returns (int callDeltaDecimal, int putDeltaDecimal) {\n    uint tAnnualised = _annualise(bsInput.timeToExpirySec);\n    uint spotPrecise = bsInput.spotDecimal.decimalToPreciseDecimal();\n\n    (int d1, ) = _d1d2(\n      tAnnualised,\n      bsInput.volatilityDecimal.decimalToPreciseDecimal(),\n      spotPrecise,\n      bsInput.strikePriceDecimal.decimalToPreciseDecimal(),\n      bsInput.rateDecimal.decimalToPreciseDecimal()\n    );\n\n    (int callDelta, int putDelta) = _delta(d1);\n    return (callDelta.preciseDecimalToDecimal(), putDelta.preciseDecimalToDecimal());\n  }\n\n  /**\n   * @dev Returns non-normalized vega given parameters. Quoted in cents.\n   */\n  function vega(BlackScholesInputs memory bsInput) public pure returns (uint vegaDecimal) {\n    uint tAnnualised = _annualise(bsInput.timeToExpirySec);\n    uint spotPrecise = bsInput.spotDecimal.decimalToPreciseDecimal();\n\n    (int d1, ) = _d1d2(\n      tAnnualised,\n      bsInput.volatilityDecimal.decimalToPreciseDecimal(),\n      spotPrecise,\n      bsInput.strikePriceDecimal.decimalToPreciseDecimal(),\n      bsInput.rateDecimal.decimalToPreciseDecimal()\n    );\n    return _vega(tAnnualised, spotPrecise, d1).preciseDecimalToDecimal();\n  }\n\n  //////////////////////\n  // Computing Greeks //\n  //////////////////////\n\n  /**\n   * @dev Returns internal coefficients of the Black-Scholes call price formula, d1 and d2.\n   * @param tAnnualised Number of years to expiry\n   * @param volatility Implied volatility over the period til expiry as a percentage\n   * @param spot The current price of the base asset\n   * @param strikePrice The strikePrice price of the option\n   * @param rate The percentage risk free rate + carry cost\n   */\n  function _d1d2(\n    uint tAnnualised,\n    uint volatility,\n    uint spot,\n    uint strikePrice,\n    int rate\n  ) internal pure returns (int d1, int d2) {\n    // Set minimum values for tAnnualised and volatility to not break computation in extreme scenarios\n    // These values will result in option prices reflecting only the difference in stock/strikePrice, which is expected.\n    // This should be caught before calling this function, however the function shouldn't break if the values are 0.\n    tAnnualised = tAnnualised < MIN_T_ANNUALISED ? MIN_T_ANNUALISED : tAnnualised;\n    volatility = volatility < MIN_VOLATILITY ? MIN_VOLATILITY : volatility;\n\n    int vtSqrt = int(volatility.multiplyDecimalRoundPrecise(_sqrtPrecise(tAnnualised)));\n    int log = FixedPointMathLib.lnPrecise(int(spot.divideDecimalRoundPrecise(strikePrice)));\n    int v2t = (int(volatility.multiplyDecimalRoundPrecise(volatility) / 2) + rate).multiplyDecimalRoundPrecise(\n      int(tAnnualised)\n    );\n    d1 = (log + v2t).divideDecimalRoundPrecise(vtSqrt);\n    d2 = d1 - vtSqrt;\n  }\n\n  /**\n   * @dev Internal coefficients of the Black-Scholes call price formula.\n   * @param tAnnualised Number of years to expiry\n   * @param spot The current price of the base asset\n   * @param strikePrice The strikePrice price of the option\n   * @param rate The percentage risk free rate + carry cost\n   * @param d1 Internal coefficient of Black-Scholes\n   * @param d2 Internal coefficient of Black-Scholes\n   */\n  function _optionPrices(\n    uint tAnnualised,\n    uint spot,\n    uint strikePrice,\n    int rate,\n    int d1,\n    int d2\n  ) internal pure returns (uint call, uint put) {\n    uint strikePricePV = strikePrice.multiplyDecimalRoundPrecise(\n      FixedPointMathLib.expPrecise(int(-rate.multiplyDecimalRoundPrecise(int(tAnnualised))))\n    );\n    uint spotNd1 = spot.multiplyDecimalRoundPrecise(_stdNormalCDF(d1));\n    uint strikePriceNd2 = strikePricePV.multiplyDecimalRoundPrecise(_stdNormalCDF(d2));\n\n    // We clamp to zero if the minuend is less than the subtrahend\n    // In some scenarios it may be better to compute put price instead and derive call from it depending on which way\n    // around is more precise.\n    call = strikePriceNd2 <= spotNd1 ? spotNd1 - strikePriceNd2 : 0;\n    put = call + strikePricePV;\n    put = spot <= put ? put - spot : 0;\n  }\n\n  /*\n   * Greeks\n   */\n\n  /**\n   * @dev Returns the option's delta value\n   * @param d1 Internal coefficient of Black-Scholes\n   */\n  function _delta(int d1) internal pure returns (int callDelta, int putDelta) {\n    callDelta = int(_stdNormalCDF(d1));\n    putDelta = callDelta - int(PRECISE_UNIT);\n  }\n\n  /**\n   * @dev Returns the option's vega value based on d1. Quoted in cents.\n   *\n   * @param d1 Internal coefficient of Black-Scholes\n   * @param tAnnualised Number of years to expiry\n   * @param spot The current price of the base asset\n   */\n  function _vega(uint tAnnualised, uint spot, int d1) internal pure returns (uint) {\n    return _sqrtPrecise(tAnnualised).multiplyDecimalRoundPrecise(_stdNormal(d1).multiplyDecimalRoundPrecise(spot));\n  }\n\n  /**\n   * @dev Returns the option's vega value with expiry modified to be at least VEGA_STANDARDISATION_MIN_DAYS\n   * @param d1 Internal coefficient of Black-Scholes\n   * @param spot The current price of the base asset\n   * @param timeToExpirySec Number of seconds to expiry\n   */\n  function _standardVega(int d1, uint spot, uint timeToExpirySec) internal pure returns (uint, uint) {\n    uint tAnnualised = _annualise(timeToExpirySec);\n    uint normalisationFactor = _getVegaNormalisationFactorPrecise(timeToExpirySec);\n    uint vegaPrecise = _vega(tAnnualised, spot, d1);\n    return (vegaPrecise, vegaPrecise.multiplyDecimalRoundPrecise(normalisationFactor));\n  }\n\n  function _getVegaNormalisationFactorPrecise(uint timeToExpirySec) internal pure returns (uint) {\n    timeToExpirySec = timeToExpirySec < VEGA_STANDARDISATION_MIN_DAYS ? VEGA_STANDARDISATION_MIN_DAYS : timeToExpirySec;\n    uint daysToExpiry = timeToExpirySec / 1 days;\n    uint thirty = 30 * PRECISE_UNIT;\n    return _sqrtPrecise(thirty / daysToExpiry) / 100;\n  }\n\n  /////////////////////\n  // Math Operations //\n  /////////////////////\n\n  /// @notice Calculates the square root of x, rounding down (borrowed from https://github.com/paulrberg/prb-math)\n  /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n  /// @param x The uint256 number for which to calculate the square root.\n  /// @return result The result as an uint256.\n  function _sqrt(uint x) internal pure returns (uint result) {\n    if (x == 0) {\n      return 0;\n    }\n\n    // Calculate the square root of the perfect square of a power of two that is the closest to x.\n    uint xAux = uint(x);\n    result = 1;\n    if (xAux >= 0x100000000000000000000000000000000) {\n      xAux >>= 128;\n      result <<= 64;\n    }\n    if (xAux >= 0x10000000000000000) {\n      xAux >>= 64;\n      result <<= 32;\n    }\n    if (xAux >= 0x100000000) {\n      xAux >>= 32;\n      result <<= 16;\n    }\n    if (xAux >= 0x10000) {\n      xAux >>= 16;\n      result <<= 8;\n    }\n    if (xAux >= 0x100) {\n      xAux >>= 8;\n      result <<= 4;\n    }\n    if (xAux >= 0x10) {\n      xAux >>= 4;\n      result <<= 2;\n    }\n    if (xAux >= 0x8) {\n      result <<= 1;\n    }\n\n    // The operations can never overflow because the result is max 2^127 when it enters this block.\n    unchecked {\n      result = (result + x / result) >> 1;\n      result = (result + x / result) >> 1;\n      result = (result + x / result) >> 1;\n      result = (result + x / result) >> 1;\n      result = (result + x / result) >> 1;\n      result = (result + x / result) >> 1;\n      result = (result + x / result) >> 1; // Seven iterations should be enough\n      uint roundedDownResult = x / result;\n      return result >= roundedDownResult ? roundedDownResult : result;\n    }\n  }\n\n  /**\n   * @dev Returns the square root of the value using Newton's method.\n   */\n  function _sqrtPrecise(uint x) internal pure returns (uint) {\n    // Add in an extra unit factor for the square root to gobble;\n    // otherwise, sqrt(x * UNIT) = sqrt(x) * sqrt(UNIT)\n    return _sqrt(x * PRECISE_UNIT);\n  }\n\n  /**\n   * @dev The standard normal distribution of the value.\n   */\n  function _stdNormal(int x) internal pure returns (uint) {\n    return\n      FixedPointMathLib.expPrecise(int(-x.multiplyDecimalRoundPrecise(x / 2))).divideDecimalRoundPrecise(SQRT_TWOPI);\n  }\n\n  /**\n   * @dev The standard normal cumulative distribution of the value.\n   * borrowed from a C++ implementation https://stackoverflow.com/a/23119456\n   */\n  function _stdNormalCDF(int x) public pure returns (uint) {\n    uint z = Math.abs(x);\n    int c = 0;\n\n    if (z <= 37 * PRECISE_UNIT) {\n      uint e = FixedPointMathLib.expPrecise(-int(z.multiplyDecimalRoundPrecise(z / 2)));\n      if (z < SPLIT) {\n        c = int(\n          (_stdNormalCDFNumerator(z).divideDecimalRoundPrecise(_stdNormalCDFDenom(z)).multiplyDecimalRoundPrecise(e))\n        );\n      } else {\n        uint f = (z +\n          PRECISE_UNIT.divideDecimalRoundPrecise(\n            z +\n              (2 * PRECISE_UNIT).divideDecimalRoundPrecise(\n                z +\n                  (3 * PRECISE_UNIT).divideDecimalRoundPrecise(\n                    z + (4 * PRECISE_UNIT).divideDecimalRoundPrecise(z + ((PRECISE_UNIT * 13) / 20))\n                  )\n              )\n          ));\n        c = int(e.divideDecimalRoundPrecise(f.multiplyDecimalRoundPrecise(SQRT_TWOPI)));\n      }\n    }\n    return uint((x <= 0 ? c : (int(PRECISE_UNIT) - c)));\n  }\n\n  /**\n   * @dev Helper for _stdNormalCDF\n   */\n  function _stdNormalCDFNumerator(uint z) internal pure returns (uint) {\n    uint numeratorInner = ((((((N6 * z) / PRECISE_UNIT + N5) * z) / PRECISE_UNIT + N4) * z) / PRECISE_UNIT + N3);\n    return (((((numeratorInner * z) / PRECISE_UNIT + N2) * z) / PRECISE_UNIT + N1) * z) / PRECISE_UNIT + N0;\n  }\n\n  /**\n   * @dev Helper for _stdNormalCDF\n   */\n  function _stdNormalCDFDenom(uint z) internal pure returns (uint) {\n    uint denominatorInner = ((((((M7 * z) / PRECISE_UNIT + M6) * z) / PRECISE_UNIT + M5) * z) / PRECISE_UNIT + M4);\n    return\n      (((((((denominatorInner * z) / PRECISE_UNIT + M3) * z) / PRECISE_UNIT + M2) * z) / PRECISE_UNIT + M1) * z) /\n      PRECISE_UNIT +\n      M0;\n  }\n\n  /**\n   * @dev Converts an integer number of seconds to a fractional number of years.\n   */\n  function _annualise(uint secs) internal pure returns (uint yearFraction) {\n    return secs.divideDecimalRoundPrecise(SECONDS_PER_YEAR);\n  }\n}\n"
    },
    "contracts/libraries/ConvertDecimals.sol": {
      "content": "//SPDX-License-Identifier: ISC\npragma solidity 0.8.16;\n\n// Libraries\nimport \"./Math.sol\";\n\n/**\n * @title ConvertDecimals\n * @author Lyra\n * @dev Contract to convert amounts to and from erc20 tokens to 18 dp.\n */\nlibrary ConvertDecimals {\n  /// @dev Converts amount from token native dp to 18 dp. This cuts off precision for decimals > 18.\n  function convertTo18(uint amount, uint8 decimals) internal pure returns (uint) {\n    return (amount * 1e18) / (10 ** decimals);\n  }\n\n  /// @dev Converts amount from 18dp to token.decimals(). This cuts off precision for decimals < 18.\n  function convertFrom18(uint amount, uint8 decimals) internal pure returns (uint) {\n    return (amount * (10 ** decimals)) / 1e18;\n  }\n\n  /// @dev Converts amount from a given precisionFactor to 18 dp. This cuts off precision for decimals > 18.\n  function normaliseTo18(uint amount, uint precisionFactor) internal pure returns (uint) {\n    return (amount * 1e18) / precisionFactor;\n  }\n\n  // Loses precision\n  /// @dev Converts amount from 18dp to the given precisionFactor. This cuts off precision for decimals < 18.\n  function normaliseFrom18(uint amount, uint precisionFactor) internal pure returns (uint) {\n    return (amount * precisionFactor) / 1e18;\n  }\n\n  /// @dev Ensure a value converted from 18dp is rounded up, to ensure the value requested is covered fully.\n  function convertFrom18AndRoundUp(uint amount, uint8 assetDecimals) internal pure returns (uint amountConverted) {\n    // If we lost precision due to conversion we ensure the lost value is rounded up to the lowest precision of the asset\n    if (assetDecimals < 18) {\n      // Taking the ceil of 10^(18-decimals) will ensure the first n (asset decimals) have precision when converting\n      amount = Math.ceil(amount, 10 ** (18 - assetDecimals));\n    }\n    amountConverted = ConvertDecimals.convertFrom18(amount, assetDecimals);\n  }\n}\n"
    },
    "contracts/libraries/FixedPointMathLib.sol": {
      "content": "//SPDX-License-Identifier: ISC\npragma solidity 0.8.16;\n\n// Slightly modified version of:\n// - https://github.com/recmo/experiment-solexp/blob/605738f3ed72d6c67a414e992be58262fbc9bb80/src/FixedPointMathLib.sol\nlibrary FixedPointMathLib {\n  /// @dev Computes ln(x) for a 1e27 fixed point. Loses 9 last significant digits of precision.\n  function lnPrecise(int x) internal pure returns (int r) {\n    return ln(x / 1e9) * 1e9;\n  }\n\n  /// @dev Computes e ^ x for a 1e27 fixed point. Loses 9 last significant digits of precision.\n  function expPrecise(int x) internal pure returns (uint r) {\n    return exp(x / 1e9) * 1e9;\n  }\n\n  // Computes ln(x) in 1e18 fixed point.\n  // Reverts if x is negative or zero.\n  // Consumes 670 gas.\n  function ln(int x) internal pure returns (int r) {\n    unchecked {\n      if (x < 1) {\n        if (x < 0) revert LnNegativeUndefined();\n        revert Overflow();\n      }\n\n      // We want to convert x from 10**18 fixed point to 2**96 fixed point.\n      // We do this by multiplying by 2**96 / 10**18.\n      // But since ln(x * C) = ln(x) + ln(C), we can simply do nothing here\n      // and add ln(2**96 / 10**18) at the end.\n\n      // Reduce range of x to (1, 2) * 2**96\n      // ln(2^k * x) = k * ln(2) + ln(x)\n      // Note: inlining ilog2 saves 8 gas.\n      int k = int(ilog2(uint(x))) - 96;\n      x <<= uint(159 - k);\n      x = int(uint(x) >> 159);\n\n      // Evaluate using a (8, 8)-term rational approximation\n      // p is made monic, we will multiply by a scale factor later\n      int p = x + 3273285459638523848632254066296;\n      p = ((p * x) >> 96) + 24828157081833163892658089445524;\n      p = ((p * x) >> 96) + 43456485725739037958740375743393;\n      p = ((p * x) >> 96) - 11111509109440967052023855526967;\n      p = ((p * x) >> 96) - 45023709667254063763336534515857;\n      p = ((p * x) >> 96) - 14706773417378608786704636184526;\n      p = p * x - (795164235651350426258249787498 << 96);\n      //emit log_named_int(\"p\", p);\n      // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n      // q is monic by convention\n      int q = x + 5573035233440673466300451813936;\n      q = ((q * x) >> 96) + 71694874799317883764090561454958;\n      q = ((q * x) >> 96) + 283447036172924575727196451306956;\n      q = ((q * x) >> 96) + 401686690394027663651624208769553;\n      q = ((q * x) >> 96) + 204048457590392012362485061816622;\n      q = ((q * x) >> 96) + 31853899698501571402653359427138;\n      q = ((q * x) >> 96) + 909429971244387300277376558375;\n      assembly {\n        // Div in assembly because solidity adds a zero check despite the `unchecked`.\n        // The q polynomial is known not to have zeros in the domain. (All roots are complex)\n        // No scaling required because p is already 2**96 too large.\n        r := sdiv(p, q)\n      }\n      // r is in the range (0, 0.125) * 2**96\n\n      // Finalization, we need to\n      // * multiply by the scale factor s = 5.549…\n      // * add ln(2**96 / 10**18)\n      // * add k * ln(2)\n      // * multiply by 10**18 / 2**96 = 5**18 >> 78\n      // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\n      r *= 1677202110996718588342820967067443963516166;\n      // add ln(2) * k * 5e18 * 2**192\n      r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\n      // add ln(2**96 / 10**18) * 5e18 * 2**192\n      r += 600920179829731861736702779321621459595472258049074101567377883020018308;\n      // base conversion: mul 2**18 / 2**192\n      r >>= 174;\n    }\n  }\n\n  // Integer log2\n  // @returns floor(log2(x)) if x is nonzero, otherwise 0. This is the same\n  //          as the location of the highest set bit.\n  // Consumes 232 gas. This could have been an 3 gas EVM opcode though.\n  function ilog2(uint x) internal pure returns (uint r) {\n    assembly {\n      r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n      r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n      r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n      r := or(r, shl(4, lt(0xffff, shr(r, x))))\n      r := or(r, shl(3, lt(0xff, shr(r, x))))\n      r := or(r, shl(2, lt(0xf, shr(r, x))))\n      r := or(r, shl(1, lt(0x3, shr(r, x))))\n      r := or(r, lt(0x1, shr(r, x)))\n    }\n  }\n\n  // Computes e^x in 1e18 fixed point.\n  function exp(int x) internal pure returns (uint r) {\n    unchecked {\n      // Input x is in fixed point format, with scale factor 1/1e18.\n\n      // When the result is < 0.5 we return zero. This happens when\n      // x <= floor(log(0.5e18) * 1e18) ~ -42e18\n      if (x <= -42139678854452767551) {\n        return 0;\n      }\n\n      // When the result is > (2**255 - 1) / 1e18 we can not represent it\n      // as an int256. This happens when x >= floor(log((2**255 -1) / 1e18) * 1e18) ~ 135.\n      if (x >= 135305999368893231589) revert ExpOverflow();\n\n      // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\n      // for more intermediate precision and a binary basis. This base conversion\n      // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n      x = (x << 78) / 5 ** 18;\n\n      // Reduce range of x to (-½ ln 2, ½ ln 2) * 2**96 by factoring out powers of two\n      // such that exp(x) = exp(x') * 2**k, where k is an integer.\n      // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n      int k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\n      x = x - k * 54916777467707473351141471128;\n      // k is in the range [-61, 195].\n\n      // Evaluate using a (6, 7)-term rational approximation\n      // p is made monic, we will multiply by a scale factor later\n      int p = x + 2772001395605857295435445496992;\n      p = ((p * x) >> 96) + 44335888930127919016834873520032;\n      p = ((p * x) >> 96) + 398888492587501845352592340339721;\n      p = ((p * x) >> 96) + 1993839819670624470859228494792842;\n      p = p * x + (4385272521454847904632057985693276 << 96);\n      // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n      // Evaluate using using Knuth's scheme from p. 491.\n      int z = x + 750530180792738023273180420736;\n      z = ((z * x) >> 96) + 32788456221302202726307501949080;\n      int w = x - 2218138959503481824038194425854;\n      w = ((w * z) >> 96) + 892943633302991980437332862907700;\n      int q = z + w - 78174809823045304726920794422040;\n      q = ((q * w) >> 96) + 4203224763890128580604056984195872;\n      assembly {\n        // Div in assembly because solidity adds a zero check despite the `unchecked`.\n        // The q polynomial is known not to have zeros in the domain. (All roots are complex)\n        // No scaling required because p is already 2**96 too large.\n        r := sdiv(p, q)\n      }\n      // r should be in the range (0.09, 0.25) * 2**96.\n\n      // We now need to multiply r by\n      //  * the scale factor s = ~6.031367120...,\n      //  * the 2**k factor from the range reduction, and\n      //  * the 1e18 / 2**96 factor for base converison.\n      // We do all of this at once, with an intermediate result in 2**213 basis\n      // so the final right shift is always by a positive amount.\n      r = (uint(r) * 3822833074963236453042738258902158003155416615667) >> uint(195 - k);\n    }\n  }\n\n  error Overflow();\n  error ExpOverflow();\n  error LnNegativeUndefined();\n}\n"
    },
    "contracts/libraries/GWAV.sol": {
      "content": "//SPDX-License-Identifier: ISC\npragma solidity 0.8.16;\n\n// Libraries\nimport \"../synthetix/SignedDecimalMath.sol\";\nimport \"../synthetix/DecimalMath.sol\";\nimport \"./FixedPointMathLib.sol\";\n\n/**\n * @title Geometric Moving Average Oracle\n * @author Lyra\n * @dev Instances of stored oracle data, \"observations\", are collected in the oracle array\n *\n * The GWAV values are calculated from the blockTimestamps and \"q\" accumulator values of two Observations. When\n * requested the closest observations are scaled to the requested timestamp.\n */\nlibrary GWAV {\n  using DecimalMath for uint;\n  using SignedDecimalMath for int;\n\n  /// @dev Stores all past Observations and the current index\n  struct Params {\n    Observation[] observations;\n    uint index;\n  }\n\n  /// @dev An observation holds the cumulative log value of all historic observations (accumulator)\n  /// and other relevant fields for computing the next accumulator value.\n  /// @dev A pair of oracle Observations is used to deduce the GWAV TWAP\n  struct Observation {\n    int q; // accumulator value used to compute GWAV\n    uint nextVal; // value at the time the observation was made, used to calculate the next q value\n    uint blockTimestamp;\n  }\n\n  /////////////\n  // Setters //\n  /////////////\n\n  /**\n   * @notice Initialize the oracle array by writing the first Observation.\n   * @dev Called once for the lifecycle of the observations array\n   * @dev First Observation uses blockTimestamp as the time interval to prevent manipulation of the GWAV immediately\n   * after initialization\n   * @param self Stores past Observations and the index of the latest Observation\n   * @param newVal First observed value for blockTimestamp\n   * @param blockTimestamp Timestamp of first Observation\n   */\n  function _initialize(Params storage self, uint newVal, uint blockTimestamp) internal {\n    // if Observation older than blockTimestamp is used for GWAV,\n    // _getFirstBefore() will scale the first Observation \"q\" accordingly\n    _initializeWithManualQ(self, FixedPointMathLib.ln((int(newVal))) * int(blockTimestamp), newVal, blockTimestamp);\n  }\n\n  /**\n   * @notice Writes an oracle Observation to the GWAV array\n   * @dev Writable at most once per block. BlockTimestamp must be > last.blockTimestamp\n   * @param self Stores past Observations and the index of the latest Observation\n   * @param nextVal Value at given blockTimestamp\n   * @param blockTimestamp Current blockTimestamp\n   */\n  function _write(Params storage self, uint nextVal, uint blockTimestamp) internal {\n    Observation memory last = self.observations[self.index];\n\n    // Ensure entries are sequential\n    if (blockTimestamp < last.blockTimestamp) {\n      revert InvalidBlockTimestamp(address(this), blockTimestamp, last.blockTimestamp);\n    }\n\n    // early return if we've already written an observation this block\n    if (last.blockTimestamp == blockTimestamp) {\n      self.observations[self.index].nextVal = nextVal;\n      return;\n    }\n    // No reason to record an entry if it's the same as the last one\n    if (last.nextVal == nextVal) return;\n\n    // update accumulator value\n    // assumes the market value between the previous and current blockTimstamps was \"last.nextVal\"\n    uint timestampDelta = blockTimestamp - last.blockTimestamp;\n    int newQ = last.q + FixedPointMathLib.ln((int(last.nextVal))) * int(timestampDelta);\n\n    // update latest index and store Observation\n    uint indexUpdated = (self.index + 1);\n    self.observations.push(_transform(newQ, nextVal, blockTimestamp));\n    self.index = indexUpdated;\n  }\n\n  /////////////\n  // Getters //\n  /////////////\n\n  /**\n   * @notice Calculates the geometric moving average between two Observations A & B. These observations are scaled to\n   * the requested timestamps\n   * @dev For the current GWAV value, \"0\" may be passed in for secondsAgo\n   * @dev If timestamps A==B, returns the value at A/B.\n   * @param self Stores past Observations and the index of the latest Observation\n   * @param secondsAgoA Seconds from blockTimestamp to Observation A\n   * @param secondsAgoB Seconds from blockTimestamp to Observation B\n   */\n  function getGWAVForPeriod(Params storage self, uint secondsAgoA, uint secondsAgoB) public view returns (uint) {\n    (uint v0, int q0, uint t0) = queryFirstBeforeAndScale(self, block.timestamp, secondsAgoA);\n    (, int q1, uint t1) = queryFirstBeforeAndScale(self, block.timestamp, secondsAgoB);\n\n    // if the record found for each timestamp is the same, return the recorded value.\n    if (t0 == t1) return v0;\n\n    return uint(FixedPointMathLib.exp((q1 - q0) / int(t1 - t0)));\n  }\n\n  /**\n   * @notice Returns the GWAV accumulator/timestamps values for each \"secondsAgo\" in the array `secondsAgos[]`\n   * @param currentBlockTimestamp Timestamp of current block\n   * @param secondsAgos Array of all timestamps for which to export accumulator/timestamp values\n   */\n  function observe(\n    Params storage self,\n    uint currentBlockTimestamp,\n    uint[] memory secondsAgos\n  ) public view returns (int[] memory qCumulatives, uint[] memory timestamps) {\n    uint secondsAgosLength = secondsAgos.length;\n    qCumulatives = new int[](secondsAgosLength);\n    timestamps = new uint[](secondsAgosLength);\n    for (uint i = 0; i < secondsAgosLength; ++i) {\n      (qCumulatives[i], timestamps[i]) = queryFirstBefore(self, currentBlockTimestamp, secondsAgos[i]);\n    }\n  }\n\n  //////////////////////////////////////////////////////\n  // Querying observation closest to target timestamp //\n  //////////////////////////////////////////////////////\n\n  /**\n   * @notice Finds the first observation before a timestamp \"secondsAgo\" from the \"currentBlockTimestamp\"\n   * @dev If target falls between two Observations, the older one is returned\n   * @dev See _queryFirstBefore() for edge cases where target lands\n   * after the newest Observation or before the oldest Observation\n   * @dev Reverts if secondsAgo exceeds the currentBlockTimestamp\n   * @param self Stores past Observations and the index of the latest Observation\n   * @param currentBlockTimestamp Timestamp of current block\n   * @param secondsAgo Seconds from currentBlockTimestamp to target Observation\n   */\n  function queryFirstBefore(\n    Params storage self,\n    uint currentBlockTimestamp,\n    uint secondsAgo\n  ) internal view returns (int qCumulative, uint timestamp) {\n    uint target = currentBlockTimestamp - secondsAgo;\n    Observation memory beforeOrAt = _queryFirstBefore(self, target);\n\n    return (beforeOrAt.q, beforeOrAt.blockTimestamp);\n  }\n\n  function queryFirstBeforeAndScale(\n    Params storage self,\n    uint currentBlockTimestamp,\n    uint secondsAgo\n  ) internal view returns (uint v, int qCumulative, uint timestamp) {\n    uint target = currentBlockTimestamp - secondsAgo;\n    Observation memory beforeOrAt = _queryFirstBefore(self, target);\n\n    int timestampDelta = int(target - beforeOrAt.blockTimestamp);\n\n    return (\n      beforeOrAt.nextVal,\n      beforeOrAt.q + (FixedPointMathLib.ln(int(beforeOrAt.nextVal)) * timestampDelta),\n      target\n    );\n  }\n\n  /**\n   * @notice Finds the first observation before the \"target\" timestamp\n   * @dev Checks for trivial scenarios before entering _binarySearch()\n   * @dev Assumes _initialize() has been called\n   * @param self Stores past Observations and the index of the latest Observation\n   * @param target BlockTimestamp of target Observation\n   */\n  function _queryFirstBefore(Params storage self, uint target) private view returns (Observation memory beforeOrAt) {\n    // Case 1: target blockTimestamp is at or after the most recent Observation\n    beforeOrAt = self.observations[self.index];\n    if (beforeOrAt.blockTimestamp <= target) {\n      return (beforeOrAt);\n    }\n\n    // Now, set to the oldest observation\n    beforeOrAt = self.observations[0];\n\n    // Case 2: target blockTimestamp is older than the oldest Observation\n    // The observation is scaled to the target using the nextVal\n    if (beforeOrAt.blockTimestamp > target) {\n      return _transform((beforeOrAt.q * int(target)) / int(beforeOrAt.blockTimestamp), beforeOrAt.nextVal, target);\n    }\n\n    // Case 3: target is within the recorded Observations.\n    return self.observations[_binarySearch(self, target)];\n  }\n\n  /**\n   * @notice Finds closest Observation before target using binary search and returns its index\n   * @dev Used when the target is located within the stored observation boundaries\n   * e.g. Older than the most recent observation and younger, or the same age as, the oldest observation\n   * @return foundIndex Returns the Observation which is older than target (instead of newer)\n   * @param self Stores past Observations and the index of the latest Observation\n   * @param target BlockTimestamp of target Observation\n   */\n  function _binarySearch(Params storage self, uint target) internal view returns (uint) {\n    uint oldest = 0; // oldest observation\n    uint newest = self.index; // newest observation\n    uint i = 0;\n    while (true) {\n      i = (oldest + newest) / 2;\n      uint beforeOrAtTimestamp = self.observations[i].blockTimestamp;\n\n      uint atOrAfterTimestamp = self.observations[i + 1].blockTimestamp;\n      bool targetAtOrAfter = beforeOrAtTimestamp <= target;\n\n      // check if we've found the answer!\n      if (targetAtOrAfter && target <= atOrAfterTimestamp) break;\n\n      if (!targetAtOrAfter) {\n        newest = i - 1;\n      } else {\n        oldest = i + 1;\n      }\n    }\n\n    return i;\n  }\n\n  /////////////\n  // Utility //\n  /////////////\n\n  /**\n   * @notice Creates the first Observation with manual Q accumulator value.\n   * @param qVal Initial GWAV accumulator value\n   * @param nextVal First observed value for blockTimestamp\n   * @param blockTimestamp Timestamp of Observation\n   */\n  function _initializeWithManualQ(Params storage self, int qVal, uint nextVal, uint blockTimestamp) internal {\n    self.observations.push(Observation({q: qVal, nextVal: nextVal, blockTimestamp: blockTimestamp}));\n  }\n\n  /**\n   * @dev Creates an Observation given a GWAV accumulator, latest value, and a blockTimestamp\n   */\n  function _transform(int newQ, uint nextVal, uint blockTimestamp) private pure returns (Observation memory) {\n    return Observation({q: newQ, nextVal: nextVal, blockTimestamp: blockTimestamp});\n  }\n\n  ////////////\n  // Errors //\n  ////////////\n  error InvalidBlockTimestamp(address thrower, uint timestamp, uint lastObservedTimestamp);\n}\n"
    },
    "contracts/libraries/Math.sol": {
      "content": "//SPDX-License-Identifier: ISC\npragma solidity 0.8.16;\n\n/**\n * @title Math\n * @author Lyra\n * @dev Library to unify logic for common shared functions\n */\nlibrary Math {\n  /// @dev Return the minimum value between the two inputs\n  function min(uint x, uint y) internal pure returns (uint) {\n    return (x < y) ? x : y;\n  }\n\n  /// @dev Return the maximum value between the two inputs\n  function max(uint x, uint y) internal pure returns (uint) {\n    return (x > y) ? x : y;\n  }\n\n  /// @dev Compute the absolute value of `val`.\n  function abs(int val) internal pure returns (uint) {\n    return uint(val < 0 ? -val : val);\n  }\n\n  /// @dev Takes ceiling of a to m precision\n  /// @param m represents 1eX where X is the number of trailing 0's\n  function ceil(uint a, uint m) internal pure returns (uint) {\n    return ((a + m - 1) / m) * m;\n  }\n}\n"
    },
    "contracts/libraries/SimpleInitializable.sol": {
      "content": "//SPDX-License-Identifier: ISC\npragma solidity 0.8.16;\n\n/**\n * @title SimpleInitializable\n * @author Lyra\n * @dev Contract to enable a function to be marked as the initializer\n */\nabstract contract SimpleInitializable {\n  bool internal initialized = false;\n\n  modifier initializer() {\n    if (initialized) {\n      revert AlreadyInitialised(address(this));\n    }\n    initialized = true;\n    _;\n  }\n\n  ////////////\n  // Errors //\n  ////////////\n  error AlreadyInitialised(address thrower);\n}\n"
    },
    "contracts/LyraCalc.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.16;\n\nimport {BlackScholes} from\"./libraries/BlackScholes.sol\";\nimport {DecimalMath} from \"./synthetix/DecimalMath.sol\";\nimport {SignedDecimalMath} from \"./synthetix/SignedDecimalMath.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {IOptionMarket} from \"./interfaces/IOptionMarket.sol\";\nimport {IBaseExchangeAdapter} from \"./interfaces/IBaseExchangeAdapter.sol\";\nimport {IOptionGreekCache} from \"./interfaces/IOptionGreekCache.sol\";\nimport {IOptionMarketPricer} from \"./interfaces/IOptionMarketPricer.sol\";\nimport {ILiquidityPool} from \"./interfaces/ILiquidityPool.sol\";\n\n/**\n * @title LyraCalc\n * @author 0nika0\n * @notice A smart contract for calculating the total cost of option trades and related fees.\n * This contract leverages the Black-Scholes model and various pricing parameters to estimate trade costs.\n */\ncontract LyraCalc {\n    using DecimalMath for uint;\n    using SignedDecimalMath for int;\n    using BlackScholes for BlackScholes.BlackScholesInputs;\n    \n    // Contracts and libraries\n    IOptionMarket public optionMarket;\n    IOptionMarketPricer public optionMarketPricer;\n    IBaseExchangeAdapter public baseExchangeAdapter;\n    IOptionGreekCache public optionGreekCache;\n    ILiquidityPool public liquidityPool;\n\n    constructor(\n        address _optionMarket,\n        address _optionMarketPricer,\n        address _baseExchangeAdapter,\n        address _optionGreekCache,\n        address _liquidityPool\n    ) {\n        optionMarket = IOptionMarket(_optionMarket);\n        optionMarketPricer = IOptionMarketPricer(_optionMarketPricer);\n        baseExchangeAdapter = IBaseExchangeAdapter(_baseExchangeAdapter);\n        optionGreekCache = IOptionGreekCache(_optionGreekCache);\n        liquidityPool = ILiquidityPool(_liquidityPool);\n    }\n\n    // VIEW FUNCTIONS //\n\n    /**\n     * @notice Calculates the total cost for a given trade.\n     * @dev This function calculates the approximate value of an option trade based on various parameters.\n     * @param strikeId The ID of the strike for the option trade.\n     * @param tradeDirection The direction of the trade: OPEN, CLOSE, LIQUIDATE.\n     * @param optionType The type of the option: LONG_CALL, LONG_PUT, SHORT_CALL_BASE, SHORT_CALL_QUOTE, SHORT_PUT_QUOTE.\n     * @param amount The amount of options being traded.\n     * @param isBuy True if it's a buy trade, false if it's a sell trade.\n     * @param isForceClose True if the trade is a force close.\n     * @return totalCost The total cost of the trade including fees.\n     */\n    function calculateTotalCost(\n        uint256 strikeId,\n        IOptionMarket.TradeDirection tradeDirection, \n        IOptionMarket.OptionType optionType, \n        uint256 amount,\n        bool isBuy,\n        bool isForceClose\n    ) public view returns (uint256 totalCost) {\n        // Prepare the trade parameters based on input values\n        IOptionMarket.TradeParameters memory trade = preparetionTrade(\n            amount,\n            isBuy,\n            tradeDirection,\n            optionType,\n            isForceClose\n        );\n\n        // Get strike and board information\n        (IOptionMarket.Strike memory strike, IOptionMarket.OptionBoard memory board) = optionMarket.getStrikeAndBoard(strikeId);\n        IOptionGreekCache.StrikeCache memory strikeCache = optionGreekCache.getStrikeCache(strikeId);\n        IOptionGreekCache.OptionBoardCache memory boardCache = optionGreekCache.getOptionBoardCache(strikeCache.boardId);\n\n        // Calculate prices, delta, and standard vega using Black-Scholes model\n        BlackScholes.PricesDeltaStdVega memory pricesDeltaStdVega = calculatePricesDeltaStdVega(\n            trade.spotPrice,\n            strikeCache,\n            boardCache\n        );\n\n        // Prepare trade pricing data\n        IOptionGreekCache.TradePricing memory pricing = preparetionPricing(\n            strike,\n            strikeCache,\n            boardCache,\n            pricesDeltaStdVega.vega\n        );\n\n        // Calculate the impact of implied volatility on the trade's price\n        (, uint256 newSkew) = optionMarketPricer.ivImpactForTrade(trade, boardCache.iv, strike.skew);\n\n        // Calculate the premium for the option trade\n        uint256 premium = calculatePremium(\n            optionType,\n            amount,\n            pricesDeltaStdVega\n        );\n\n        // Calculate fees related to option price and spot price\n        uint256 optionPriceFee = calculateOptionPriceFee(premium, board.expiry);\n        uint256 spotPriceFee = calculateSpotPriceFee(trade.spotPrice, trade.amount, board.expiry);\n\n        // Calculate vega utility and variance fees\n        IOptionMarketPricer.VegaUtilFeeComponents memory vegaUtilFeeComponents = optionMarketPricer.getVegaUtilFee(\n            trade,\n            pricing\n        );\n        IOptionMarketPricer.VarianceFeeComponents memory varianceFeeComponents = optionMarketPricer.getVarianceFee(\n            trade,\n            pricing,\n            newSkew\n        );\n\n        // Calculate the total fee for the trade\n        uint totalFee = optionPriceFee +\n            spotPriceFee +\n            vegaUtilFeeComponents.vegaUtilFee +\n            varianceFeeComponents.varianceFee;\n\n        // Calculate the total cost based on trade direction and fees\n        if (trade.isBuy) {\n            totalCost = premium + totalFee;\n        } else {\n            if (totalFee > premium) {\n                totalFee = premium;\n                totalCost = 0;\n            } else {\n                totalCost = premium - totalFee;\n            }\n        }\n        // Return the calculated total cost\n    }\n\n    /**\n     * @notice Calculates option prices, delta, and standard vega using the Black-Scholes model.\n     * @dev This function calculates various option-related values using the Black-Scholes formula.\n     * @param spotPrice The current spot price of the underlying asset.\n     * @param strikeCache The cached data for the strike associated with the option.\n     * @param boardCache The cached data for the option board.\n     * @return pricesDeltaStdVega A struct containing calculated prices, delta, and standard vega.\n     */\n    function calculatePricesDeltaStdVega(\n        uint256 spotPrice,\n        IOptionGreekCache.StrikeCache memory strikeCache,\n        IOptionGreekCache.OptionBoardCache memory boardCache\n    ) public view returns (BlackScholes.PricesDeltaStdVega memory pricesDeltaStdVega) {\n        // Construct inputs for the Black-Scholes formula\n        pricesDeltaStdVega = BlackScholes\n            .BlackScholesInputs({\n                timeToExpirySec: _timeToMaturitySeconds(boardCache.expiry), // Calculate time to maturity in seconds\n                volatilityDecimal: boardCache.iv.multiplyDecimal(strikeCache.skew), // Adjusted volatility based on strike skew\n                spotDecimal: spotPrice, // Current spot price\n                strikePriceDecimal: strikeCache.strikePrice, // Strike price of the option\n                rateDecimal: baseExchangeAdapter.rateAndCarry(address(optionMarket)) // Risk-free rate\n            })\n            .pricesDeltaStdVega();\n    }\n\n    /**\n     * @notice Retrieves the appropriate spot price based on trade direction, option type, and force close status.\n     * @param tradeDirection The direction of the trade: OPEN, CLOSE, LIQUIDATE.\n     * @param optionType The type of the option: LONG_CALL, LONG_PUT, SHORT_CALL_BASE, SHORT_CALL_QUOTE, SHORT_PUT_QUOTE.\n     * @param isForceClose True if the trade is a force close.\n     * @return spotPrice The calculated spot price for the trade.\n     */\n    function getSpotPrice(\n        IOptionMarket.TradeDirection tradeDirection,\n        IOptionMarket.OptionType optionType,\n        bool isForceClose\n    ) public view returns (uint256 spotPrice) {\n        IBaseExchangeAdapter.PriceType pricingType;\n\n        // Determine the appropriate pricing type based on trade direction and option type\n        if (tradeDirection == IOptionMarket.TradeDirection.LIQUIDATE) {\n            pricingType = IBaseExchangeAdapter.PriceType.REFERENCE;\n        } else if (optionType == IOptionMarket.OptionType.LONG_CALL || optionType == IOptionMarket.OptionType.SHORT_PUT_QUOTE) {\n            pricingType = tradeDirection == IOptionMarket.TradeDirection.OPEN\n                ? IBaseExchangeAdapter.PriceType.MAX_PRICE\n                : (isForceClose ? IBaseExchangeAdapter.PriceType.FORCE_MIN : IBaseExchangeAdapter.PriceType.MIN_PRICE);\n        } else {\n            pricingType = tradeDirection == IOptionMarket.TradeDirection.OPEN\n                ? IBaseExchangeAdapter.PriceType.MIN_PRICE\n                : (isForceClose ? IBaseExchangeAdapter.PriceType.FORCE_MAX : IBaseExchangeAdapter.PriceType.MAX_PRICE);\n        }\n\n        // Retrieve the spot price based on the selected pricing type\n        spotPrice = baseExchangeAdapter.getSpotPriceForMarket(address(optionMarket), pricingType);\n    }\n\n    /**\n     * @notice Calculates the fee based on spot price and trade amount, taking into account time weighting.\n     * @param spotPrice The current spot price of the underlying asset.\n     * @param amount The amount of options being traded.\n     * @param expiry The expiration time of the options.\n     * @return fee The calculated fee based on the provided spot price and trade parameters.\n     */\n    function calculateSpotPriceFee(\n        uint256 spotPrice,\n        uint256 amount,\n        uint256 expiry\n    ) public view returns (uint256 fee) {\n        // Get the pricing parameters from the option market pricer\n        IOptionMarketPricer.PricingParameters memory pricingParams = optionMarketPricer.pricingParams();\n\n        // Calculate the time-weighted spot price fee using the provided parameters\n        uint timeWeightedSpotPriceFee = optionMarketPricer.getTimeWeightedFee(\n            expiry,\n            pricingParams.spotPriceFee1xPoint,\n            pricingParams.spotPriceFee2xPoint,\n            pricingParams.spotPriceFeeCoefficient\n        );\n\n        // Calculate the final fee by multiplying the time-weighted fee by the spot price and trade amount\n        fee = timeWeightedSpotPriceFee.multiplyDecimal(spotPrice).multiplyDecimal(amount);\n    }\n\n    /**\n     * @notice Calculates the fee based on the option premium and expiration time, considering time weighting.\n     * @param premium The premium amount of the option.\n     * @param expiry The expiration time of the option.\n     * @return fee The calculated fee based on the provided premium and expiration time.\n     */\n    function calculateOptionPriceFee(\n        uint256 premium,\n        uint256 expiry\n    ) public view returns (uint256 fee) {\n        // Get the pricing parameters from the option market pricer\n        IOptionMarketPricer.PricingParameters memory pricingParams = optionMarketPricer.pricingParams();\n\n        // Calculate the time-weighted option price fee using the provided parameters\n        uint timeWeightedOptionPriceFee = optionMarketPricer.getTimeWeightedFee(\n            expiry,\n            pricingParams.optionPriceFee1xPoint,\n            pricingParams.optionPriceFee2xPoint,\n            pricingParams.optionPriceFeeCoefficient\n        );\n\n        // Calculate the final fee by multiplying the time-weighted fee by the option premium\n        fee = timeWeightedOptionPriceFee.multiplyDecimal(premium);\n    } \n\n    /**\n     * @notice Prepares deal parameters for totalCost calculation.\n     * @param amount The amount of options being traded.\n     * @param isBuy True if it's a buy trade, false if it's a sell trade.\n     * @param tradeDirection The direction of the trade: OPEN, CLOSE, LIQUIDATE.\n     * @param optionType The type of the option: LONG_CALL, LONG_PUT, SHORT_CALL_BASE, SHORT_CALL_QUOTE, SHORT_PUT_QUOTE.\n     * @param isForceClose True if the trade is a force close.\n     * @return trade The populated trade parameters.\n    */\n    function preparetionTrade(\n        uint256 amount,\n        bool isBuy,\n        IOptionMarket.TradeDirection tradeDirection,\n        IOptionMarket.OptionType optionType,\n        bool isForceClose\n    ) public view returns (IOptionMarket.TradeParameters memory trade) {\n        // Get the current Net Asset Value (NAV) from the liquidity pool\n        trade.liquidity.NAV = liquidityPool.getLiquidity().NAV;\n\n        // Populate the trade parameters based on provided inputs\n        trade.amount = amount;\n        trade.isForceClose = isForceClose;\n        trade.isBuy = isBuy;\n\n        // Get the spot price for the trade based on trade direction, option type, and force close status\n        trade.spotPrice = getSpotPrice(\n            tradeDirection,\n            optionType,\n            isForceClose\n        );\n\n        // Set the option type and trade direction\n        trade.optionType = optionType;\n        trade.tradeDirection = tradeDirection;\n    }\n\n    /**\n     * @notice Prepares trade pricing data based on strike and greek cache information.\n     * @param strike The information about the strike.\n     * @param strikeCache The cached data for the strike.\n     * @param boardCache The cached data for the option board.\n     * @param vega The calculated vega value.\n     * @return pricing The populated trade pricing data.\n     */\n    function preparetionPricing(\n        IOptionMarket.Strike memory strike,\n        IOptionGreekCache.StrikeCache memory strikeCache,\n        IOptionGreekCache.OptionBoardCache memory boardCache,\n        uint256 vega\n    ) public view returns (IOptionGreekCache.TradePricing memory pricing) {\n        // Get the global cache from the option Greek cache\n        IOptionGreekCache.GlobalCache memory globalCache = optionGreekCache.getGlobalCache();\n\n        // Calculate new exposures and net standard vega difference\n        int256 newCallExposure = SafeCast.toInt256(strike.longCall) - SafeCast.toInt256(strike.shortCallBase + strike.shortCallQuote);\n        int256 newPutExposure = SafeCast.toInt256(strike.longPut) - SafeCast.toInt256(strike.shortPut);\n        int256 netStdVegaDiff = (newCallExposure + newPutExposure - strikeCache.callExposure - strikeCache.putExposure)\n            .multiplyDecimal(SafeCast.toInt256(strikeCache.greeks.stdVega));\n\n\n        // Populate pricing data based on provided inputs\n        pricing.preTradeAmmNetStdVega = -globalCache.netGreeks.netStdVega;\n        pricing.postTradeAmmNetStdVega = -globalCache.netGreeks.netStdVega + netStdVegaDiff;\n        pricing.volTraded = boardCache.iv.multiplyDecimal(strikeCache.skew);\n        pricing.vega = vega;\n        pricing.ivVariance = boardCache.ivVariance;\n    }\n\n    // INTERNAL FUNCTIONS //\n\n    /**\n     * @notice Calculates the time remaining to maturity in seconds for a given expiry timestamp.\n     * @param expiry The expiration timestamp of the option.\n     * @return timeToMaturitySeconds The remaining time to maturity in seconds.\n     */\n    function _timeToMaturitySeconds(uint256 expiry) internal view returns (uint256 timeToMaturitySeconds) {\n        // Calculate the time remaining to maturity using the _getSecondsTo function\n        timeToMaturitySeconds = _getSecondsTo(block.timestamp, expiry);\n    }\n\n    // PURE FUNCTIONS //\n\n    /**\n     * @notice Calculates the premium for the option trade based on the option type and other parameters.\n     * @param optionType The type of the option: LONG_CALL, LONG_PUT, SHORT_CALL_BASE, SHORT_CALL_QUOTE, SHORT_PUT_QUOTE.\n     * @param amount The amount of options being traded.\n     * @param pricesDeltaStdVega The struct containing calculated prices, delta, and standard vega.\n     * @return premium The calculated premium for the option trade.\n     */\n    function calculatePremium(\n        IOptionMarket.OptionType optionType,\n        uint256 amount,\n        BlackScholes.PricesDeltaStdVega memory pricesDeltaStdVega\n    ) public pure returns (uint256 premium) {\n        // Determine the appropriate option price based on the option type\n        uint256 optionPrice = (optionType != IOptionMarket.OptionType.LONG_PUT && optionType != IOptionMarket.OptionType.SHORT_PUT_QUOTE)\n            ? pricesDeltaStdVega.callPrice\n            : pricesDeltaStdVega.putPrice;\n        // Calculate the premium by multiplying the option price by the trade amount\n        premium = optionPrice.multiplyDecimal(amount);\n    }\n\n    /**\n     * @notice Calculates the time difference in seconds between two timestamps.\n     * @param fromTime The starting timestamp.\n     * @param toTime The ending timestamp.\n     * @return secondsTo The time difference in seconds between the two timestamps.\n     */\n    function _getSecondsTo(uint256 fromTime, uint256 toTime) internal pure returns (uint256) {\n        // Calculate the time difference in seconds between the two timestamps\n        if (toTime > fromTime) {\n            return toTime - fromTime;\n        }\n            return 0;\n    }\n\n}\n"
    },
    "contracts/synthetix/AbstractOwned.sol": {
      "content": "//SPDX-License-Identifier: MIT\n//\n//Copyright (c) 2019 Synthetix\n//\n//Permission is hereby granted, free of charge, to any person obtaining a copy\n//of this software and associated documentation files (the \"Software\"), to deal\n//in the Software without restriction, including without limitation the rights\n//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n//copies of the Software, and to permit persons to whom the Software is\n//furnished to do so, subject to the following conditions:\n//\n//The above copyright notice and this permission notice shall be included in all\n//copies or substantial portions of the Software.\n//\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n//SOFTWARE.\n\npragma solidity 0.8.16;\n\n/**\n * @title Owned\n * @author Synthetix\n * @dev Synthetix owned contract without constructor and custom errors\n * @dev https://docs.synthetix.io/contracts/source/contracts/owned\n */\nabstract contract AbstractOwned {\n  address public owner;\n  address public nominatedOwner;\n  uint[48] private __gap;\n\n  function nominateNewOwner(address _owner) external onlyOwner {\n    nominatedOwner = _owner;\n    emit OwnerNominated(_owner);\n  }\n\n  function acceptOwnership() external {\n    if (msg.sender != nominatedOwner) {\n      revert OnlyNominatedOwner(address(this), msg.sender, nominatedOwner);\n    }\n    emit OwnerChanged(owner, nominatedOwner);\n    owner = nominatedOwner;\n    nominatedOwner = address(0);\n  }\n\n  modifier onlyOwner() {\n    _onlyOwner();\n    _;\n  }\n\n  function _onlyOwner() private view {\n    if (msg.sender != owner) {\n      revert OnlyOwner(address(this), msg.sender, owner);\n    }\n  }\n\n  event OwnerNominated(address newOwner);\n  event OwnerChanged(address oldOwner, address newOwner);\n\n  ////////////\n  // Errors //\n  ////////////\n  error OnlyOwner(address thrower, address caller, address owner);\n  error OnlyNominatedOwner(address thrower, address caller, address nominatedOwner);\n}\n"
    },
    "contracts/synthetix/DecimalMath.sol": {
      "content": "//SPDX-License-Identifier: MIT\n//\n//Copyright (c) 2019 Synthetix\n//\n//Permission is hereby granted, free of charge, to any person obtaining a copy\n//of this software and associated documentation files (the \"Software\"), to deal\n//in the Software without restriction, including without limitation the rights\n//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n//copies of the Software, and to permit persons to whom the Software is\n//furnished to do so, subject to the following conditions:\n//\n//The above copyright notice and this permission notice shall be included in all\n//copies or substantial portions of the Software.\n//\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n//SOFTWARE.\n\npragma solidity 0.8.16;\n\n/**\n * @title DecimalMath\n * @author Lyra\n * @dev Modified synthetix SafeDecimalMath to include internal arithmetic underflow/overflow.\n * @dev https://docs.synthetix.io/contracts/source/libraries/SafeDecimalMath/\n */\n\nlibrary DecimalMath {\n  /* Number of decimal places in the representations. */\n  uint8 public constant decimals = 18;\n  uint8 public constant highPrecisionDecimals = 27;\n\n  /* The number representing 1.0. */\n  uint public constant UNIT = 10 ** uint(decimals);\n\n  /* The number representing 1.0 for higher fidelity numbers. */\n  uint public constant PRECISE_UNIT = 10 ** uint(highPrecisionDecimals);\n  uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10 ** uint(highPrecisionDecimals - decimals);\n\n  /**\n   * @return Provides an interface to UNIT.\n   */\n  function unit() external pure returns (uint) {\n    return UNIT;\n  }\n\n  /**\n   * @return Provides an interface to PRECISE_UNIT.\n   */\n  function preciseUnit() external pure returns (uint) {\n    return PRECISE_UNIT;\n  }\n\n  /**\n   * @return The result of multiplying x and y, interpreting the operands as fixed-point\n   * decimals.\n   *\n   * @dev A unit factor is divided out after the product of x and y is evaluated,\n   * so that product must be less than 2**256. As this is an integer division,\n   * the internal division always rounds down. This helps save on gas. Rounding\n   * is more expensive on gas.\n   */\n  function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\n    /* Divide by UNIT to remove the extra factor introduced by the product. */\n    return (x * y) / UNIT;\n  }\n\n  /**\n   * @return The result of safely multiplying x and y, interpreting the operands\n   * as fixed-point decimals of the specified precision unit.\n   *\n   * @dev The operands should be in the form of a the specified unit factor which will be\n   * divided out after the product of x and y is evaluated, so that product must be\n   * less than 2**256.\n   *\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\n   * (eg. small fractions or percentages).\n   */\n  function _multiplyDecimalRound(uint x, uint y, uint precisionUnit) private pure returns (uint) {\n    /* Divide by UNIT to remove the extra factor introduced by the product. */\n    uint quotientTimesTen = (x * y) / (precisionUnit / 10);\n\n    if (quotientTimesTen % 10 >= 5) {\n      quotientTimesTen += 10;\n    }\n\n    return quotientTimesTen / 10;\n  }\n\n  /**\n   * @return The result of safely multiplying x and y, interpreting the operands\n   * as fixed-point decimals of a precise unit.\n   *\n   * @dev The operands should be in the precise unit factor which will be\n   * divided out after the product of x and y is evaluated, so that product must be\n   * less than 2**256.\n   *\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\n   * (eg. small fractions or percentages).\n   */\n  function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n    return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n  }\n\n  /**\n   * @return The result of safely multiplying x and y, interpreting the operands\n   * as fixed-point decimals of a standard unit.\n   *\n   * @dev The operands should be in the standard unit factor which will be\n   * divided out after the product of x and y is evaluated, so that product must be\n   * less than 2**256.\n   *\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\n   * (eg. small fractions or percentages).\n   */\n  function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\n    return _multiplyDecimalRound(x, y, UNIT);\n  }\n\n  /**\n   * @return The result of safely dividing x and y. The return value is a high\n   * precision decimal.\n   *\n   * @dev y is divided after the product of x and the standard precision unit\n   * is evaluated, so the product of x and UNIT must be less than 2**256. As\n   * this is an integer division, the result is always rounded down.\n   * This helps save on gas. Rounding is more expensive on gas.\n   */\n  function divideDecimal(uint x, uint y) internal pure returns (uint) {\n    /* Reintroduce the UNIT factor that will be divided out by y. */\n    return (x * UNIT) / y;\n  }\n\n  /**\n   * @return The result of safely dividing x and y. The return value is as a rounded\n   * decimal in the precision unit specified in the parameter.\n   *\n   * @dev y is divided after the product of x and the specified precision unit\n   * is evaluated, so the product of x and the specified precision unit must\n   * be less than 2**256. The result is rounded to the nearest increment.\n   */\n  function _divideDecimalRound(uint x, uint y, uint precisionUnit) private pure returns (uint) {\n    uint resultTimesTen = (x * (precisionUnit * 10)) / y;\n\n    if (resultTimesTen % 10 >= 5) {\n      resultTimesTen += 10;\n    }\n\n    return resultTimesTen / 10;\n  }\n\n  /**\n   * @return The result of safely dividing x and y. The return value is as a rounded\n   * standard precision decimal.\n   *\n   * @dev y is divided after the product of x and the standard precision unit\n   * is evaluated, so the product of x and the standard precision unit must\n   * be less than 2**256. The result is rounded to the nearest increment.\n   */\n  function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\n    return _divideDecimalRound(x, y, UNIT);\n  }\n\n  /**\n   * @return The result of safely dividing x and y. The return value is as a rounded\n   * high precision decimal.\n   *\n   * @dev y is divided after the product of x and the high precision unit\n   * is evaluated, so the product of x and the high precision unit must\n   * be less than 2**256. The result is rounded to the nearest increment.\n   */\n  function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n    return _divideDecimalRound(x, y, PRECISE_UNIT);\n  }\n\n  /**\n   * @dev Convert a standard decimal representation to a high precision one.\n   */\n  function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\n    return i * UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR;\n  }\n\n  /**\n   * @dev Convert a high precision decimal to a standard decimal representation.\n   */\n  function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\n    uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n    if (quotientTimesTen % 10 >= 5) {\n      quotientTimesTen += 10;\n    }\n\n    return quotientTimesTen / 10;\n  }\n}\n"
    },
    "contracts/synthetix/Owned.sol": {
      "content": "//SPDX-License-Identifier: MIT\n//\n//Copyright (c) 2019 Synthetix\n//\n//Permission is hereby granted, free of charge, to any person obtaining a copy\n//of this software and associated documentation files (the \"Software\"), to deal\n//in the Software without restriction, including without limitation the rights\n//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n//copies of the Software, and to permit persons to whom the Software is\n//furnished to do so, subject to the following conditions:\n//\n//The above copyright notice and this permission notice shall be included in all\n//copies or substantial portions of the Software.\n//\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n//SOFTWARE.\n\npragma solidity 0.8.16;\n\nimport \"./AbstractOwned.sol\";\n\n/**\n * @title Owned\n * @author Synthetix\n * @dev Slightly modified Synthetix owned contract, so that first owner is msg.sender\n * @dev https://docs.synthetix.io/contracts/source/contracts/owned\n */\ncontract Owned is AbstractOwned {\n  constructor() {\n    owner = msg.sender;\n    emit OwnerChanged(address(0), msg.sender);\n  }\n}\n"
    },
    "contracts/synthetix/SignedDecimalMath.sol": {
      "content": "//SPDX-License-Identifier: MIT\n//\n//Copyright (c) 2019 Synthetix\n//\n//Permission is hereby granted, free of charge, to any person obtaining a copy\n//of this software and associated documentation files (the \"Software\"), to deal\n//in the Software without restriction, including without limitation the rights\n//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n//copies of the Software, and to permit persons to whom the Software is\n//furnished to do so, subject to the following conditions:\n//\n//The above copyright notice and this permission notice shall be included in all\n//copies or substantial portions of the Software.\n//\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n//SOFTWARE.\n\npragma solidity 0.8.16;\n\n/**\n * @title SignedDecimalMath\n * @author Lyra\n * @dev Modified synthetix SafeSignedDecimalMath to include internal arithmetic underflow/overflow.\n * @dev https://docs.synthetix.io/contracts/source/libraries/safedecimalmath\n */\nlibrary SignedDecimalMath {\n  /* Number of decimal places in the representations. */\n  uint8 public constant decimals = 18;\n  uint8 public constant highPrecisionDecimals = 27;\n\n  /* The number representing 1.0. */\n  int public constant UNIT = int(10 ** uint(decimals));\n\n  /* The number representing 1.0 for higher fidelity numbers. */\n  int public constant PRECISE_UNIT = int(10 ** uint(highPrecisionDecimals));\n  int private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = int(10 ** uint(highPrecisionDecimals - decimals));\n\n  /**\n   * @return Provides an interface to UNIT.\n   */\n  function unit() external pure returns (int) {\n    return UNIT;\n  }\n\n  /**\n   * @return Provides an interface to PRECISE_UNIT.\n   */\n  function preciseUnit() external pure returns (int) {\n    return PRECISE_UNIT;\n  }\n\n  /**\n   * @dev Rounds an input with an extra zero of precision, returning the result without the extra zero.\n   * Half increments round away from zero; positive numbers at a half increment are rounded up,\n   * while negative such numbers are rounded down. This behaviour is designed to be consistent with the\n   * unsigned version of this library (SafeDecimalMath).\n   */\n  function _roundDividingByTen(int valueTimesTen) private pure returns (int) {\n    int increment;\n    if (valueTimesTen % 10 >= 5) {\n      increment = 10;\n    } else if (valueTimesTen % 10 <= -5) {\n      increment = -10;\n    }\n    return (valueTimesTen + increment) / 10;\n  }\n\n  /**\n   * @return The result of multiplying x and y, interpreting the operands as fixed-point\n   * decimals.\n   *\n   * @dev A unit factor is divided out after the product of x and y is evaluated,\n   * so that product must be less than 2**256. As this is an integer division,\n   * the internal division always rounds down. This helps save on gas. Rounding\n   * is more expensive on gas.\n   */\n  function multiplyDecimal(int x, int y) internal pure returns (int) {\n    /* Divide by UNIT to remove the extra factor introduced by the product. */\n    return (x * y) / UNIT;\n  }\n\n  /**\n   * @return The result of safely multiplying x and y, interpreting the operands\n   * as fixed-point decimals of the specified precision unit.\n   *\n   * @dev The operands should be in the form of a the specified unit factor which will be\n   * divided out after the product of x and y is evaluated, so that product must be\n   * less than 2**256.\n   *\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\n   * (eg. small fractions or percentages).\n   */\n  function _multiplyDecimalRound(int x, int y, int precisionUnit) private pure returns (int) {\n    /* Divide by UNIT to remove the extra factor introduced by the product. */\n    int quotientTimesTen = (x * y) / (precisionUnit / 10);\n    return _roundDividingByTen(quotientTimesTen);\n  }\n\n  /**\n   * @return The result of safely multiplying x and y, interpreting the operands\n   * as fixed-point decimals of a precise unit.\n   *\n   * @dev The operands should be in the precise unit factor which will be\n   * divided out after the product of x and y is evaluated, so that product must be\n   * less than 2**256.\n   *\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\n   * (eg. small fractions or percentages).\n   */\n  function multiplyDecimalRoundPrecise(int x, int y) internal pure returns (int) {\n    return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n  }\n\n  /**\n   * @return The result of safely multiplying x and y, interpreting the operands\n   * as fixed-point decimals of a standard unit.\n   *\n   * @dev The operands should be in the standard unit factor which will be\n   * divided out after the product of x and y is evaluated, so that product must be\n   * less than 2**256.\n   *\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\n   * (eg. small fractions or percentages).\n   */\n  function multiplyDecimalRound(int x, int y) internal pure returns (int) {\n    return _multiplyDecimalRound(x, y, UNIT);\n  }\n\n  /**\n   * @return The result of safely dividing x and y. The return value is a high\n   * precision decimal.\n   *\n   * @dev y is divided after the product of x and the standard precision unit\n   * is evaluated, so the product of x and UNIT must be less than 2**256. As\n   * this is an integer division, the result is always rounded down.\n   * This helps save on gas. Rounding is more expensive on gas.\n   */\n  function divideDecimal(int x, int y) internal pure returns (int) {\n    /* Reintroduce the UNIT factor that will be divided out by y. */\n    return (x * UNIT) / y;\n  }\n\n  /**\n   * @return The result of safely dividing x and y. The return value is as a rounded\n   * decimal in the precision unit specified in the parameter.\n   *\n   * @dev y is divided after the product of x and the specified precision unit\n   * is evaluated, so the product of x and the specified precision unit must\n   * be less than 2**256. The result is rounded to the nearest increment.\n   */\n  function _divideDecimalRound(int x, int y, int precisionUnit) private pure returns (int) {\n    int resultTimesTen = (x * (precisionUnit * 10)) / y;\n    return _roundDividingByTen(resultTimesTen);\n  }\n\n  /**\n   * @return The result of safely dividing x and y. The return value is as a rounded\n   * standard precision decimal.\n   *\n   * @dev y is divided after the product of x and the standard precision unit\n   * is evaluated, so the product of x and the standard precision unit must\n   * be less than 2**256. The result is rounded to the nearest increment.\n   */\n  function divideDecimalRound(int x, int y) internal pure returns (int) {\n    return _divideDecimalRound(x, y, UNIT);\n  }\n\n  /**\n   * @return The result of safely dividing x and y. The return value is as a rounded\n   * high precision decimal.\n   *\n   * @dev y is divided after the product of x and the high precision unit\n   * is evaluated, so the product of x and the high precision unit must\n   * be less than 2**256. The result is rounded to the nearest increment.\n   */\n  function divideDecimalRoundPrecise(int x, int y) internal pure returns (int) {\n    return _divideDecimalRound(x, y, PRECISE_UNIT);\n  }\n\n  /**\n   * @dev Convert a standard decimal representation to a high precision one.\n   */\n  function decimalToPreciseDecimal(int i) internal pure returns (int) {\n    return i * UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR;\n  }\n\n  /**\n   * @dev Convert a high precision decimal to a standard decimal representation.\n   */\n  function preciseDecimalToDecimal(int i) internal pure returns (int) {\n    int quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n    return _roundDividingByTen(quotientTimesTen);\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}